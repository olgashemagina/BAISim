<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>awplflib: C:/_alt/_proj/awplflib/src/LFEye.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">awplflib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">LFEye.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_l_f_eye_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="___l_f_8h.html">_LF.h</a>&quot;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#pragma hdrstop</span></div>
<div class="line"><a name="l00004"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">    4</a></span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>  = 12;</div>
<div class="line"><a name="l00005"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">    5</a></span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a> = 12;</div>
<div class="line"><a name="l00006"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">    6</a></span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>   = <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>*<a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#ad3146f534a9e2c469fd3ad7430353e1d">    7</a></span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="_l_f_eye_8cpp.html#ad3146f534a9e2c469fd3ad7430353e1d">c_nEyeSize2</a>  = <a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>*<a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>;</div>
<div class="line"><a name="l00008"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#ae2ccb26d0b914506544b2360d7e76ec4">    8</a></span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="_l_f_eye_8cpp.html#ae2ccb26d0b914506544b2360d7e76ec4">c_nEyeHalfW</a>  = <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a> / 2;</div>
<div class="line"><a name="l00009"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#aecda569513727fdc2eb85baae781ddb3">    9</a></span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="_l_f_eye_8cpp.html#aecda569513727fdc2eb85baae781ddb3">c_nEyeHalfH</a>  = <a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a> / 2;</div>
<div class="line"><a name="l00010"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#a614da9e44621b6c13ed31f9a312d49c6">   10</a></span>&#160;<span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="_l_f_eye_8cpp.html#a614da9e44621b6c13ed31f9a312d49c6">c_fCorrThr</a> = 0.5;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span>  gCount = 0;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">char</span>* gExtJPG  = <span class="stringliteral">&quot;.jpg&quot;</span>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">char</span>* gExtXYZ  = <span class="stringliteral">&quot;.dat&quot;</span>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">char</span>* gExtDAT  = <span class="stringliteral">&quot;.txt&quot;</span>;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">мозаичное изображение окрестности глаза.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">|img11, img12, ... , img1M|</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">|img21, img22, ... , img2M|</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">|.........................|</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">|imgN1, imgN2, ... , imgNM|</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">Размер мозаики MxN</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">M = 2*W / step; - число столбцов мозики</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">N = 2* / step; - число строк мозаики 
Ширина изображения: Width  = M*W0,
W0 - ширина элемента мозаики. W0 = c_nEyeWidth
Высота изображения: Htight = N*H0,
H0 - высота элемента мозаики. H0 = c_nEyeHeight
*/
class TLFMosaic : public TLFObject
{
protected:
    int   m_NumCol;         // число столбцов
    int   m_NumRow;         // число строк
    int   m_ElWidth;        // высота элемента
    int   m_ElHeight;       // ширина элемента
    int   m_dx;             // расстояние между элементами по горизонтали
    int   m_dy;             // расстояние между элементами по вертикали

    awpImage* m_pImage;     // изображение мозаики

    void CreateMosaic();
public:
    TLFMosaic();
    TLFMosaic(int NumCol, int NumRow, int W0 = 16, int H0 = 16, int dx = 0, int dy = 0);
    virtual ~TLFMosaic();
    bool AddElement(int col, int row, awpImage* pImage);

    bool SaveMosaic(const char* lpFileName);

};


static void _bSaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\t%i\t%i\n&quot;, x,y,pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

static void _SaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsXYZ(lpFileName, pImage);
   }

}

static void _bSaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\n&quot;, pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

// сохраняет изображение AWP в виде текстового файла
// который содержит один столбец данных -
// значаения пикселей
static void _SaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsDAT(lpFileName, pImage);
   }
}
// отрисовка области поиска глаз на копии входного изображения
// и сохраниение копии под именем eye_area.jpg
#define DRAW_EYE_CLIP_RECTS                                                   \
        dLRect.left = LBase.X - s[0]*L/2; dLRect.top = LBase.Y - s[0]*L/2;      \
        dLRect.right= LBase.X + s[0]*L/2; dLRect.bottom = LBase.Y + s[0]*L/2;   \
        dRRect.left = RBase.X - s[0]*L/2; dRRect.top = RBase.Y - s[0]*L/2;      \
        dRRect.right= RBase.X + s[0]*L/2; dRRect.bottom = RBase.Y + s[0]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[1]*L/2; dLRect.top = LBase.Y - s[1]*L/2;      \
        dLRect.right= LBase.X + s[1]*L/2; dLRect.bottom = LBase.Y + s[1]*L/2;   \
        dRRect.left = RBase.X - s[1]*L/2; dRRect.top = RBase.Y - s[1]*L/2;      \
        dRRect.right= RBase.X + s[1]*L/2; dRRect.bottom = RBase.Y + s[1]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[2]*L/2; dLRect.top = LBase.Y - s[2]*L/2;      \
        dLRect.right= LBase.X + s[2]*L/2; dLRect.bottom = LBase.Y + s[2]*L/2;   \
        dRRect.left = RBase.X - s[2]*L/2; dRRect.top = RBase.Y - s[2]*L/2;      \
        dRRect.right= RBase.X + s[2]*L/2; dRRect.bottom = RBase.Y + s[2]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[3]*L/2; dLRect.top = LBase.Y - s[3]*L/2;      \
        dLRect.right= LBase.X + s[3]*L/2; dLRect.bottom = LBase.Y + s[3]*L/2;   \
        dRRect.left = RBase.X - s[3]*L/2; dRRect.top = RBase.Y - s[3]*L/2;      \
        dRRect.right= RBase.X + s[3]*L/2; dRRect.bottom = RBase.Y + s[3]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[4]*L/2; dLRect.top = LBase.Y - s[4]*L/2;      \
        dLRect.right= LBase.X + s[4]*L/2; dLRect.bottom = LBase.Y + s[4]*L/2;   \
        dRRect.left = RBase.X - s[4]*L/2; dRRect.top = RBase.Y - s[4]*L/2;      \
        dRRect.right= RBase.X + s[4]*L/2; dRRect.bottom = RBase.Y + s[4]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \


#define DRAW_EYE_AREA(v)  \
    awpImage* pCopy = NULL;                                       \
    if (awpCopyImage(image.GetImage(), &amp;pCopy) == AWP_OK)         \
    {                                                             \
        awpRect dLRect;                                           \
        awpRect dRRect;                                           \
        dLRect.left = LBase.X - W; dLRect.top = LBase.Y - W;      \
        dLRect.right= LBase.X + W; dLRect.bottom = LBase.Y + W;   \
        dRRect.left = RBase.X - W; dRRect.top = RBase.Y - W;      \
        dRRect.right= RBase.X + W; dRRect.bottom = RBase.Y + W;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 128);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 128);                      \
        if (v)                                                    \
          DRAW_EYE_CLIP_RECTS                                     \
        awpSaveImage(&quot;eye_area.jpg&quot; , pCopy);                     \
        awpReleaseImage(&amp;pCopy);                                  \
    }                                                             \



// реализация мозаики
TLFMosaic::TLFMosaic()
{
    m_pImage = NULL;

    m_NumCol = 4;
    m_NumRow = 4;

    m_ElWidth = 16;
    m_ElHeight = 16;

    m_dx = 0;
    m_dy = 0;

    CreateMosaic();
}

TLFMosaic::TLFMosaic(int NumCol, int NumRow, int W0, int H0, int dx, int dy)
{
    m_pImage = NULL;

    m_NumCol = NumCol;
    m_NumRow = NumRow;

    m_ElWidth = W0;
    m_ElHeight = H0;

    m_dx = dx;
    m_dy = dy;

    CreateMosaic();
}
TLFMosaic::~TLFMosaic()
{
    if (m_pImage)
        awpReleaseImage (&amp;m_pImage);
}
bool TLFMosaic::AddElement(int col, int row, awpImage* pImage)
{
    // преобразование изображения
    if (pImage == NULL)
        return false;
    if (pImage-&gt;bChannels != 1)
        return false;
    if (pImage-&gt;dwType != AWP_BYTE)
        return false;

    awpResize(pImage, m_ElWidth, m_ElHeight);

    awpPoint p;
    p.X = m_dx + col*(m_ElWidth + m_dx);
    p.Y = m_dy + row*(m_ElHeight + m_dy);

    return awpPasteRect(pImage, m_pImage, p) == AWP_OK;
}
// сохранение мозаики на диск
bool TLFMosaic::SaveMosaic(const char* lpFileName)
{
    if (m_pImage)
        return awpSaveImage(lpFileName, m_pImage) == AWP_OK;
    else
        return false;
}

void TLFMosaic::CreateMosaic()
{
   int ImageWidth  = 0;
   int ImageHeight = 0;

   ImageWidth  = m_dx + m_NumCol*(m_ElWidth + m_dx);
   ImageHeight = m_dy + m_NumRow*(m_ElHeight + m_dy);

   awpCreateImage(&amp;m_pImage, ImageWidth, ImageHeight, 1, AWP_BYTE);
}
// добавление изображения глаза в мозаику
#define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">Ширина изображения: Width  = M*W0,</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">W0 - ширина элемента мозаики. W0 = c_nEyeWidth</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">Высота изображения: Htight = N*H0,</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">H0 - высота элемента мозаики. H0 = c_nEyeHeight</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l00036"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html">   36</a></span>&#160;<span class="keyword">class </span><a class="code" href="class_t_l_f_mosaic.html">TLFMosaic</a> : <span class="keyword">public</span> <a class="code" href="class_t_l_f_object.html">TLFObject</a></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;{</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="keyword">protected</span>:</div>
<div class="line"><a name="l00039"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#a08af8e3d00915acfc7ff7cb0884161be">   39</a></span>&#160;    <span class="keywordtype">int</span>   <a class="code" href="class_t_l_f_mosaic.html#a08af8e3d00915acfc7ff7cb0884161be">m_NumCol</a>;         <span class="comment">// число столбцов</span></div>
<div class="line"><a name="l00040"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#aa768306206ff35d9ef36ad4eb84b0050">   40</a></span>&#160;    <span class="keywordtype">int</span>   <a class="code" href="class_t_l_f_mosaic.html#aa768306206ff35d9ef36ad4eb84b0050">m_NumRow</a>;         <span class="comment">// число строк     int   m_ElWidth;        // высота элемента
    int   m_ElHeight;       // ширина элемента
    int   m_dx;             // расстояние между элементами по горизонтали
    int   m_dy;             // расстояние между элементами по вертикали

    awpImage* m_pImage;     // изображение мозаики

    void CreateMosaic();
public:
    TLFMosaic();
    TLFMosaic(int NumCol, int NumRow, int W0 = 16, int H0 = 16, int dx = 0, int dy = 0);
    virtual ~TLFMosaic();
    bool AddElement(int col, int row, awpImage* pImage);

    bool SaveMosaic(const char* lpFileName);

};


static void _bSaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\t%i\t%i\n&quot;, x,y,pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

static void _SaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsXYZ(lpFileName, pImage);
   }

}

static void _bSaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\n&quot;, pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

// сохраняет изображение AWP в виде текстового файла
// который содержит один столбец данных -
// значаения пикселей
static void _SaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsDAT(lpFileName, pImage);
   }
}
// отрисовка области поиска глаз на копии входного изображения
// и сохраниение копии под именем eye_area.jpg
#define DRAW_EYE_CLIP_RECTS                                                   \
        dLRect.left = LBase.X - s[0]*L/2; dLRect.top = LBase.Y - s[0]*L/2;      \
        dLRect.right= LBase.X + s[0]*L/2; dLRect.bottom = LBase.Y + s[0]*L/2;   \
        dRRect.left = RBase.X - s[0]*L/2; dRRect.top = RBase.Y - s[0]*L/2;      \
        dRRect.right= RBase.X + s[0]*L/2; dRRect.bottom = RBase.Y + s[0]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[1]*L/2; dLRect.top = LBase.Y - s[1]*L/2;      \
        dLRect.right= LBase.X + s[1]*L/2; dLRect.bottom = LBase.Y + s[1]*L/2;   \
        dRRect.left = RBase.X - s[1]*L/2; dRRect.top = RBase.Y - s[1]*L/2;      \
        dRRect.right= RBase.X + s[1]*L/2; dRRect.bottom = RBase.Y + s[1]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[2]*L/2; dLRect.top = LBase.Y - s[2]*L/2;      \
        dLRect.right= LBase.X + s[2]*L/2; dLRect.bottom = LBase.Y + s[2]*L/2;   \
        dRRect.left = RBase.X - s[2]*L/2; dRRect.top = RBase.Y - s[2]*L/2;      \
        dRRect.right= RBase.X + s[2]*L/2; dRRect.bottom = RBase.Y + s[2]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[3]*L/2; dLRect.top = LBase.Y - s[3]*L/2;      \
        dLRect.right= LBase.X + s[3]*L/2; dLRect.bottom = LBase.Y + s[3]*L/2;   \
        dRRect.left = RBase.X - s[3]*L/2; dRRect.top = RBase.Y - s[3]*L/2;      \
        dRRect.right= RBase.X + s[3]*L/2; dRRect.bottom = RBase.Y + s[3]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[4]*L/2; dLRect.top = LBase.Y - s[4]*L/2;      \
        dLRect.right= LBase.X + s[4]*L/2; dLRect.bottom = LBase.Y + s[4]*L/2;   \
        dRRect.left = RBase.X - s[4]*L/2; dRRect.top = RBase.Y - s[4]*L/2;      \
        dRRect.right= RBase.X + s[4]*L/2; dRRect.bottom = RBase.Y + s[4]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \


#define DRAW_EYE_AREA(v)  \
    awpImage* pCopy = NULL;                                       \
    if (awpCopyImage(image.GetImage(), &amp;pCopy) == AWP_OK)         \
    {                                                             \
        awpRect dLRect;                                           \
        awpRect dRRect;                                           \
        dLRect.left = LBase.X - W; dLRect.top = LBase.Y - W;      \
        dLRect.right= LBase.X + W; dLRect.bottom = LBase.Y + W;   \
        dRRect.left = RBase.X - W; dRRect.top = RBase.Y - W;      \
        dRRect.right= RBase.X + W; dRRect.bottom = RBase.Y + W;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 128);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 128);                      \
        if (v)                                                    \
          DRAW_EYE_CLIP_RECTS                                     \
        awpSaveImage(&quot;eye_area.jpg&quot; , pCopy);                     \
        awpReleaseImage(&amp;pCopy);                                  \
    }                                                             \



// реализация мозаики
TLFMosaic::TLFMosaic()
{
    m_pImage = NULL;

    m_NumCol = 4;
    m_NumRow = 4;

    m_ElWidth = 16;
    m_ElHeight = 16;

    m_dx = 0;
    m_dy = 0;

    CreateMosaic();
}

TLFMosaic::TLFMosaic(int NumCol, int NumRow, int W0, int H0, int dx, int dy)
{
    m_pImage = NULL;

    m_NumCol = NumCol;
    m_NumRow = NumRow;

    m_ElWidth = W0;
    m_ElHeight = H0;

    m_dx = dx;
    m_dy = dy;

    CreateMosaic();
}
TLFMosaic::~TLFMosaic()
{
    if (m_pImage)
        awpReleaseImage (&amp;m_pImage);
}
bool TLFMosaic::AddElement(int col, int row, awpImage* pImage)
{
    // преобразование изображения
    if (pImage == NULL)
        return false;
    if (pImage-&gt;bChannels != 1)
        return false;
    if (pImage-&gt;dwType != AWP_BYTE)
        return false;

    awpResize(pImage, m_ElWidth, m_ElHeight);

    awpPoint p;
    p.X = m_dx + col*(m_ElWidth + m_dx);
    p.Y = m_dy + row*(m_ElHeight + m_dy);

    return awpPasteRect(pImage, m_pImage, p) == AWP_OK;
}
// сохранение мозаики на диск
bool TLFMosaic::SaveMosaic(const char* lpFileName)
{
    if (m_pImage)
        return awpSaveImage(lpFileName, m_pImage) == AWP_OK;
    else
        return false;
}

void TLFMosaic::CreateMosaic()
{
   int ImageWidth  = 0;
   int ImageHeight = 0;

   ImageWidth  = m_dx + m_NumCol*(m_ElWidth + m_dx);
   ImageHeight = m_dy + m_NumRow*(m_ElHeight + m_dy);

   awpCreateImage(&amp;m_pImage, ImageWidth, ImageHeight, 1, AWP_BYTE);
}
// добавление изображения глаза в мозаику
#define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00041"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">   41</a></span>&#160;    <span class="keywordtype">int</span>   <a class="code" href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">m_ElWidth</a>;        <span class="comment">// высота элемента</span></div>
<div class="line"><a name="l00042"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">   42</a></span>&#160;    <span class="keywordtype">int</span>   <a class="code" href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">m_ElHeight</a>;       <span class="comment">// ширина элемента</span></div>
<div class="line"><a name="l00043"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">   43</a></span>&#160;    <span class="keywordtype">int</span>   <a class="code" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">m_dx</a>;             <span class="comment">// расстояние между элементами по горизонтали     int   m_dy;             // расстояние между элементами по вертикали

    awpImage* m_pImage;     // изображение мозаики

    void CreateMosaic();
public:
    TLFMosaic();
    TLFMosaic(int NumCol, int NumRow, int W0 = 16, int H0 = 16, int dx = 0, int dy = 0);
    virtual ~TLFMosaic();
    bool AddElement(int col, int row, awpImage* pImage);

    bool SaveMosaic(const char* lpFileName);

};


static void _bSaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\t%i\t%i\n&quot;, x,y,pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

static void _SaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsXYZ(lpFileName, pImage);
   }

}

static void _bSaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\n&quot;, pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

// сохраняет изображение AWP в виде текстового файла
// который содержит один столбец данных -
// значаения пикселей
static void _SaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsDAT(lpFileName, pImage);
   }
}
// отрисовка области поиска глаз на копии входного изображения
// и сохраниение копии под именем eye_area.jpg
#define DRAW_EYE_CLIP_RECTS                                                   \
        dLRect.left = LBase.X - s[0]*L/2; dLRect.top = LBase.Y - s[0]*L/2;      \
        dLRect.right= LBase.X + s[0]*L/2; dLRect.bottom = LBase.Y + s[0]*L/2;   \
        dRRect.left = RBase.X - s[0]*L/2; dRRect.top = RBase.Y - s[0]*L/2;      \
        dRRect.right= RBase.X + s[0]*L/2; dRRect.bottom = RBase.Y + s[0]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[1]*L/2; dLRect.top = LBase.Y - s[1]*L/2;      \
        dLRect.right= LBase.X + s[1]*L/2; dLRect.bottom = LBase.Y + s[1]*L/2;   \
        dRRect.left = RBase.X - s[1]*L/2; dRRect.top = RBase.Y - s[1]*L/2;      \
        dRRect.right= RBase.X + s[1]*L/2; dRRect.bottom = RBase.Y + s[1]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[2]*L/2; dLRect.top = LBase.Y - s[2]*L/2;      \
        dLRect.right= LBase.X + s[2]*L/2; dLRect.bottom = LBase.Y + s[2]*L/2;   \
        dRRect.left = RBase.X - s[2]*L/2; dRRect.top = RBase.Y - s[2]*L/2;      \
        dRRect.right= RBase.X + s[2]*L/2; dRRect.bottom = RBase.Y + s[2]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[3]*L/2; dLRect.top = LBase.Y - s[3]*L/2;      \
        dLRect.right= LBase.X + s[3]*L/2; dLRect.bottom = LBase.Y + s[3]*L/2;   \
        dRRect.left = RBase.X - s[3]*L/2; dRRect.top = RBase.Y - s[3]*L/2;      \
        dRRect.right= RBase.X + s[3]*L/2; dRRect.bottom = RBase.Y + s[3]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[4]*L/2; dLRect.top = LBase.Y - s[4]*L/2;      \
        dLRect.right= LBase.X + s[4]*L/2; dLRect.bottom = LBase.Y + s[4]*L/2;   \
        dRRect.left = RBase.X - s[4]*L/2; dRRect.top = RBase.Y - s[4]*L/2;      \
        dRRect.right= RBase.X + s[4]*L/2; dRRect.bottom = RBase.Y + s[4]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \


#define DRAW_EYE_AREA(v)  \
    awpImage* pCopy = NULL;                                       \
    if (awpCopyImage(image.GetImage(), &amp;pCopy) == AWP_OK)         \
    {                                                             \
        awpRect dLRect;                                           \
        awpRect dRRect;                                           \
        dLRect.left = LBase.X - W; dLRect.top = LBase.Y - W;      \
        dLRect.right= LBase.X + W; dLRect.bottom = LBase.Y + W;   \
        dRRect.left = RBase.X - W; dRRect.top = RBase.Y - W;      \
        dRRect.right= RBase.X + W; dRRect.bottom = RBase.Y + W;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 128);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 128);                      \
        if (v)                                                    \
          DRAW_EYE_CLIP_RECTS                                     \
        awpSaveImage(&quot;eye_area.jpg&quot; , pCopy);                     \
        awpReleaseImage(&amp;pCopy);                                  \
    }                                                             \



// реализация мозаики
TLFMosaic::TLFMosaic()
{
    m_pImage = NULL;

    m_NumCol = 4;
    m_NumRow = 4;

    m_ElWidth = 16;
    m_ElHeight = 16;

    m_dx = 0;
    m_dy = 0;

    CreateMosaic();
}

TLFMosaic::TLFMosaic(int NumCol, int NumRow, int W0, int H0, int dx, int dy)
{
    m_pImage = NULL;

    m_NumCol = NumCol;
    m_NumRow = NumRow;

    m_ElWidth = W0;
    m_ElHeight = H0;

    m_dx = dx;
    m_dy = dy;

    CreateMosaic();
}
TLFMosaic::~TLFMosaic()
{
    if (m_pImage)
        awpReleaseImage (&amp;m_pImage);
}
bool TLFMosaic::AddElement(int col, int row, awpImage* pImage)
{
    // преобразование изображения
    if (pImage == NULL)
        return false;
    if (pImage-&gt;bChannels != 1)
        return false;
    if (pImage-&gt;dwType != AWP_BYTE)
        return false;

    awpResize(pImage, m_ElWidth, m_ElHeight);

    awpPoint p;
    p.X = m_dx + col*(m_ElWidth + m_dx);
    p.Y = m_dy + row*(m_ElHeight + m_dy);

    return awpPasteRect(pImage, m_pImage, p) == AWP_OK;
}
// сохранение мозаики на диск
bool TLFMosaic::SaveMosaic(const char* lpFileName)
{
    if (m_pImage)
        return awpSaveImage(lpFileName, m_pImage) == AWP_OK;
    else
        return false;
}

void TLFMosaic::CreateMosaic()
{
   int ImageWidth  = 0;
   int ImageHeight = 0;

   ImageWidth  = m_dx + m_NumCol*(m_ElWidth + m_dx);
   ImageHeight = m_dy + m_NumRow*(m_ElHeight + m_dy);

   awpCreateImage(&amp;m_pImage, ImageWidth, ImageHeight, 1, AWP_BYTE);
}
// добавление изображения глаза в мозаику
#define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00044"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">   44</a></span>&#160;    <span class="keywordtype">int</span>   <a class="code" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">m_dy</a>;             <span class="comment">// расстояние между элементами по вертикали 
    awpImage* m_pImage;     // изображение мозаики

    void CreateMosaic();
public:
    TLFMosaic();
    TLFMosaic(int NumCol, int NumRow, int W0 = 16, int H0 = 16, int dx = 0, int dy = 0);
    virtual ~TLFMosaic();
    bool AddElement(int col, int row, awpImage* pImage);

    bool SaveMosaic(const char* lpFileName);

};


static void _bSaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\t%i\t%i\n&quot;, x,y,pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

static void _SaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsXYZ(lpFileName, pImage);
   }

}

static void _bSaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\n&quot;, pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

// сохраняет изображение AWP в виде текстового файла
// который содержит один столбец данных -
// значаения пикселей
static void _SaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsDAT(lpFileName, pImage);
   }
}
// отрисовка области поиска глаз на копии входного изображения
// и сохраниение копии под именем eye_area.jpg
#define DRAW_EYE_CLIP_RECTS                                                   \
        dLRect.left = LBase.X - s[0]*L/2; dLRect.top = LBase.Y - s[0]*L/2;      \
        dLRect.right= LBase.X + s[0]*L/2; dLRect.bottom = LBase.Y + s[0]*L/2;   \
        dRRect.left = RBase.X - s[0]*L/2; dRRect.top = RBase.Y - s[0]*L/2;      \
        dRRect.right= RBase.X + s[0]*L/2; dRRect.bottom = RBase.Y + s[0]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[1]*L/2; dLRect.top = LBase.Y - s[1]*L/2;      \
        dLRect.right= LBase.X + s[1]*L/2; dLRect.bottom = LBase.Y + s[1]*L/2;   \
        dRRect.left = RBase.X - s[1]*L/2; dRRect.top = RBase.Y - s[1]*L/2;      \
        dRRect.right= RBase.X + s[1]*L/2; dRRect.bottom = RBase.Y + s[1]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[2]*L/2; dLRect.top = LBase.Y - s[2]*L/2;      \
        dLRect.right= LBase.X + s[2]*L/2; dLRect.bottom = LBase.Y + s[2]*L/2;   \
        dRRect.left = RBase.X - s[2]*L/2; dRRect.top = RBase.Y - s[2]*L/2;      \
        dRRect.right= RBase.X + s[2]*L/2; dRRect.bottom = RBase.Y + s[2]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[3]*L/2; dLRect.top = LBase.Y - s[3]*L/2;      \
        dLRect.right= LBase.X + s[3]*L/2; dLRect.bottom = LBase.Y + s[3]*L/2;   \
        dRRect.left = RBase.X - s[3]*L/2; dRRect.top = RBase.Y - s[3]*L/2;      \
        dRRect.right= RBase.X + s[3]*L/2; dRRect.bottom = RBase.Y + s[3]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[4]*L/2; dLRect.top = LBase.Y - s[4]*L/2;      \
        dLRect.right= LBase.X + s[4]*L/2; dLRect.bottom = LBase.Y + s[4]*L/2;   \
        dRRect.left = RBase.X - s[4]*L/2; dRRect.top = RBase.Y - s[4]*L/2;      \
        dRRect.right= RBase.X + s[4]*L/2; dRRect.bottom = RBase.Y + s[4]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \


#define DRAW_EYE_AREA(v)  \
    awpImage* pCopy = NULL;                                       \
    if (awpCopyImage(image.GetImage(), &amp;pCopy) == AWP_OK)         \
    {                                                             \
        awpRect dLRect;                                           \
        awpRect dRRect;                                           \
        dLRect.left = LBase.X - W; dLRect.top = LBase.Y - W;      \
        dLRect.right= LBase.X + W; dLRect.bottom = LBase.Y + W;   \
        dRRect.left = RBase.X - W; dRRect.top = RBase.Y - W;      \
        dRRect.right= RBase.X + W; dRRect.bottom = RBase.Y + W;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 128);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 128);                      \
        if (v)                                                    \
          DRAW_EYE_CLIP_RECTS                                     \
        awpSaveImage(&quot;eye_area.jpg&quot; , pCopy);                     \
        awpReleaseImage(&amp;pCopy);                                  \
    }                                                             \



// реализация мозаики
TLFMosaic::TLFMosaic()
{
    m_pImage = NULL;

    m_NumCol = 4;
    m_NumRow = 4;

    m_ElWidth = 16;
    m_ElHeight = 16;

    m_dx = 0;
    m_dy = 0;

    CreateMosaic();
}

TLFMosaic::TLFMosaic(int NumCol, int NumRow, int W0, int H0, int dx, int dy)
{
    m_pImage = NULL;

    m_NumCol = NumCol;
    m_NumRow = NumRow;

    m_ElWidth = W0;
    m_ElHeight = H0;

    m_dx = dx;
    m_dy = dy;

    CreateMosaic();
}
TLFMosaic::~TLFMosaic()
{
    if (m_pImage)
        awpReleaseImage (&amp;m_pImage);
}
bool TLFMosaic::AddElement(int col, int row, awpImage* pImage)
{
    // преобразование изображения
    if (pImage == NULL)
        return false;
    if (pImage-&gt;bChannels != 1)
        return false;
    if (pImage-&gt;dwType != AWP_BYTE)
        return false;

    awpResize(pImage, m_ElWidth, m_ElHeight);

    awpPoint p;
    p.X = m_dx + col*(m_ElWidth + m_dx);
    p.Y = m_dy + row*(m_ElHeight + m_dy);

    return awpPasteRect(pImage, m_pImage, p) == AWP_OK;
}
// сохранение мозаики на диск
bool TLFMosaic::SaveMosaic(const char* lpFileName)
{
    if (m_pImage)
        return awpSaveImage(lpFileName, m_pImage) == AWP_OK;
    else
        return false;
}

void TLFMosaic::CreateMosaic()
{
   int ImageWidth  = 0;
   int ImageHeight = 0;

   ImageWidth  = m_dx + m_NumCol*(m_ElWidth + m_dx);
   ImageHeight = m_dy + m_NumRow*(m_ElHeight + m_dy);

   awpCreateImage(&amp;m_pImage, ImageWidth, ImageHeight, 1, AWP_BYTE);
}
// добавление изображения глаза в мозаику
#define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00046"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">   46</a></span>&#160;    awpImage* <a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a>;     <span class="comment">// изображение мозаики 
    void CreateMosaic();
public:
    TLFMosaic();
    TLFMosaic(int NumCol, int NumRow, int W0 = 16, int H0 = 16, int dx = 0, int dy = 0);
    virtual ~TLFMosaic();
    bool AddElement(int col, int row, awpImage* pImage);

    bool SaveMosaic(const char* lpFileName);

};


static void _bSaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\t%i\t%i\n&quot;, x,y,pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

static void _SaveAWPAsXYZ(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsXYZ(lpFileName, pImage);
   }

}

static void _bSaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   FILE* F = fopen(lpFileName, &quot;w+t&quot;);
   if (F != NULL)
   {
        //
        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
        for (int y = 0; y &lt; pImage-&gt;sSizeY; y++)
        {
            for (int x = 0; x &lt; pImage-&gt;sSizeX; x++)
            {
               fprintf(F, &quot;%i\n&quot;, pix[y*pImage-&gt;sSizeX + x]);
            }

        }
        fclose(F);
   }
}

// сохраняет изображение AWP в виде текстового файла
// который содержит один столбец данных -
// значаения пикселей
static void _SaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsDAT(lpFileName, pImage);
   }
}
// отрисовка области поиска глаз на копии входного изображения
// и сохраниение копии под именем eye_area.jpg
#define DRAW_EYE_CLIP_RECTS                                                   \
        dLRect.left = LBase.X - s[0]*L/2; dLRect.top = LBase.Y - s[0]*L/2;      \
        dLRect.right= LBase.X + s[0]*L/2; dLRect.bottom = LBase.Y + s[0]*L/2;   \
        dRRect.left = RBase.X - s[0]*L/2; dRRect.top = RBase.Y - s[0]*L/2;      \
        dRRect.right= RBase.X + s[0]*L/2; dRRect.bottom = RBase.Y + s[0]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[1]*L/2; dLRect.top = LBase.Y - s[1]*L/2;      \
        dLRect.right= LBase.X + s[1]*L/2; dLRect.bottom = LBase.Y + s[1]*L/2;   \
        dRRect.left = RBase.X - s[1]*L/2; dRRect.top = RBase.Y - s[1]*L/2;      \
        dRRect.right= RBase.X + s[1]*L/2; dRRect.bottom = RBase.Y + s[1]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[2]*L/2; dLRect.top = LBase.Y - s[2]*L/2;      \
        dLRect.right= LBase.X + s[2]*L/2; dLRect.bottom = LBase.Y + s[2]*L/2;   \
        dRRect.left = RBase.X - s[2]*L/2; dRRect.top = RBase.Y - s[2]*L/2;      \
        dRRect.right= RBase.X + s[2]*L/2; dRRect.bottom = RBase.Y + s[2]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[3]*L/2; dLRect.top = LBase.Y - s[3]*L/2;      \
        dLRect.right= LBase.X + s[3]*L/2; dLRect.bottom = LBase.Y + s[3]*L/2;   \
        dRRect.left = RBase.X - s[3]*L/2; dRRect.top = RBase.Y - s[3]*L/2;      \
        dRRect.right= RBase.X + s[3]*L/2; dRRect.bottom = RBase.Y + s[3]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[4]*L/2; dLRect.top = LBase.Y - s[4]*L/2;      \
        dLRect.right= LBase.X + s[4]*L/2; dLRect.bottom = LBase.Y + s[4]*L/2;   \
        dRRect.left = RBase.X - s[4]*L/2; dRRect.top = RBase.Y - s[4]*L/2;      \
        dRRect.right= RBase.X + s[4]*L/2; dRRect.bottom = RBase.Y + s[4]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \


#define DRAW_EYE_AREA(v)  \
    awpImage* pCopy = NULL;                                       \
    if (awpCopyImage(image.GetImage(), &amp;pCopy) == AWP_OK)         \
    {                                                             \
        awpRect dLRect;                                           \
        awpRect dRRect;                                           \
        dLRect.left = LBase.X - W; dLRect.top = LBase.Y - W;      \
        dLRect.right= LBase.X + W; dLRect.bottom = LBase.Y + W;   \
        dRRect.left = RBase.X - W; dRRect.top = RBase.Y - W;      \
        dRRect.right= RBase.X + W; dRRect.bottom = RBase.Y + W;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 128);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 128);                      \
        if (v)                                                    \
          DRAW_EYE_CLIP_RECTS                                     \
        awpSaveImage(&quot;eye_area.jpg&quot; , pCopy);                     \
        awpReleaseImage(&amp;pCopy);                                  \
    }                                                             \



// реализация мозаики
TLFMosaic::TLFMosaic()
{
    m_pImage = NULL;

    m_NumCol = 4;
    m_NumRow = 4;

    m_ElWidth = 16;
    m_ElHeight = 16;

    m_dx = 0;
    m_dy = 0;

    CreateMosaic();
}

TLFMosaic::TLFMosaic(int NumCol, int NumRow, int W0, int H0, int dx, int dy)
{
    m_pImage = NULL;

    m_NumCol = NumCol;
    m_NumRow = NumRow;

    m_ElWidth = W0;
    m_ElHeight = H0;

    m_dx = dx;
    m_dy = dy;

    CreateMosaic();
}
TLFMosaic::~TLFMosaic()
{
    if (m_pImage)
        awpReleaseImage (&amp;m_pImage);
}
bool TLFMosaic::AddElement(int col, int row, awpImage* pImage)
{
    // преобразование изображения
    if (pImage == NULL)
        return false;
    if (pImage-&gt;bChannels != 1)
        return false;
    if (pImage-&gt;dwType != AWP_BYTE)
        return false;

    awpResize(pImage, m_ElWidth, m_ElHeight);

    awpPoint p;
    p.X = m_dx + col*(m_ElWidth + m_dx);
    p.Y = m_dy + row*(m_ElHeight + m_dy);

    return awpPasteRect(pImage, m_pImage, p) == AWP_OK;
}
// сохранение мозаики на диск
bool TLFMosaic::SaveMosaic(const char* lpFileName)
{
    if (m_pImage)
        return awpSaveImage(lpFileName, m_pImage) == AWP_OK;
    else
        return false;
}

void TLFMosaic::CreateMosaic()
{
   int ImageWidth  = 0;
   int ImageHeight = 0;

   ImageWidth  = m_dx + m_NumCol*(m_ElWidth + m_dx);
   ImageHeight = m_dy + m_NumRow*(m_ElHeight + m_dy);

   awpCreateImage(&amp;m_pImage, ImageWidth, ImageHeight, 1, AWP_BYTE);
}
// добавление изображения глаза в мозаику
#define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="keywordtype">void</span> <a class="code" href="class_t_l_f_mosaic.html#aae2664cb9766ddb80ee09be2bc84a5a3">CreateMosaic</a>();</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#ad586648a59c911f98d869e9caeeaef1b">TLFMosaic</a>();</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#ad586648a59c911f98d869e9caeeaef1b">TLFMosaic</a>(<span class="keywordtype">int</span> NumCol, <span class="keywordtype">int</span> NumRow, <span class="keywordtype">int</span> W0 = 16, <span class="keywordtype">int</span> H0 = 16, <span class="keywordtype">int</span> dx = 0, <span class="keywordtype">int</span> dy = 0);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keyword">virtual</span> <a class="code" href="class_t_l_f_mosaic.html#ae5a3ccd113908b52c8b4d5042c965a09">~TLFMosaic</a>();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="class_t_l_f_mosaic.html#a01bfd8a0b1f59be2fa7d9357dc61b522">AddElement</a>(<span class="keywordtype">int</span> col, <span class="keywordtype">int</span> row, awpImage* pImage);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="class_t_l_f_mosaic.html#a87fddd0efef4d4f0b7a2b7f89b7df45e">SaveMosaic</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* lpFileName);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160; </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;};</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160; </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> _bSaveAWPAsXYZ(<span class="keyword">const</span> <span class="keywordtype">char</span>* lpFileName, awpImage* pImage)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;   FILE* F = fopen(lpFileName, <span class="stringliteral">&quot;w+t&quot;</span>);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;   <span class="keywordflow">if</span> (F != NULL)</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;   {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="comment">//</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        for (<span class="keywordtype">int</span> y = 0; y &lt; pImage-&gt;sSizeY; y++)</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; pImage-&gt;sSizeX; x++)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;               fprintf(F, <span class="stringliteral">&quot;%i\t%i\t%i\n&quot;</span>, x,y,pix[y*pImage-&gt;sSizeX + x]);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            }</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160; </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        }</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        fclose(F);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;   }</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;}</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> _SaveAWPAsXYZ(<span class="keyword">const</span> <span class="keywordtype">char</span>* lpFileName, awpImage* pImage)</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;   <span class="keywordflow">if</span> (pImage == NULL || lpFileName == NULL)</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;   <span class="keywordflow">switch</span> (pImage-&gt;dwType)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;   {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;      <span class="keywordflow">case</span> AWP_BYTE:</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keywordflow">return</span> _bSaveAWPAsXYZ(lpFileName, pImage);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;   }</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160; </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> _bSaveAWPAsDAT(<span class="keyword">const</span> <span class="keywordtype">char</span>* lpFileName, awpImage* pImage)</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;{</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;   FILE* F = fopen(lpFileName, <span class="stringliteral">&quot;w+t&quot;</span>);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;   <span class="keywordflow">if</span> (F != NULL)</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;   {</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        <span class="comment">//</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        for (<span class="keywordtype">int</span> y = 0; y &lt; pImage-&gt;sSizeY; y++)</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; pImage-&gt;sSizeX; x++)</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;               fprintf(F, <span class="stringliteral">&quot;%i\n&quot;</span>, pix[y*pImage-&gt;sSizeX + x]);</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            }</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160; </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        fclose(F);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;   }</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;}</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160; </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">// сохраняет изображение AWP в виде текстового файла // который содержит один столбец данных -
// значаения пикселей
static void _SaveAWPAsDAT(const char* lpFileName, awpImage* pImage)
{
   if (pImage == NULL || lpFileName == NULL)
        return;
   switch (pImage-&gt;dwType)
   {
      case AWP_BYTE:
        return _bSaveAWPAsDAT(lpFileName, pImage);
   }
}
// отрисовка области поиска глаз на копии входного изображения
// и сохраниение копии под именем eye_area.jpg
#define DRAW_EYE_CLIP_RECTS                                                   \
        dLRect.left = LBase.X - s[0]*L/2; dLRect.top = LBase.Y - s[0]*L/2;      \
        dLRect.right= LBase.X + s[0]*L/2; dLRect.bottom = LBase.Y + s[0]*L/2;   \
        dRRect.left = RBase.X - s[0]*L/2; dRRect.top = RBase.Y - s[0]*L/2;      \
        dRRect.right= RBase.X + s[0]*L/2; dRRect.bottom = RBase.Y + s[0]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[1]*L/2; dLRect.top = LBase.Y - s[1]*L/2;      \
        dLRect.right= LBase.X + s[1]*L/2; dLRect.bottom = LBase.Y + s[1]*L/2;   \
        dRRect.left = RBase.X - s[1]*L/2; dRRect.top = RBase.Y - s[1]*L/2;      \
        dRRect.right= RBase.X + s[1]*L/2; dRRect.bottom = RBase.Y + s[1]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[2]*L/2; dLRect.top = LBase.Y - s[2]*L/2;      \
        dLRect.right= LBase.X + s[2]*L/2; dLRect.bottom = LBase.Y + s[2]*L/2;   \
        dRRect.left = RBase.X - s[2]*L/2; dRRect.top = RBase.Y - s[2]*L/2;      \
        dRRect.right= RBase.X + s[2]*L/2; dRRect.bottom = RBase.Y + s[2]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[3]*L/2; dLRect.top = LBase.Y - s[3]*L/2;      \
        dLRect.right= LBase.X + s[3]*L/2; dLRect.bottom = LBase.Y + s[3]*L/2;   \
        dRRect.left = RBase.X - s[3]*L/2; dRRect.top = RBase.Y - s[3]*L/2;      \
        dRRect.right= RBase.X + s[3]*L/2; dRRect.bottom = RBase.Y + s[3]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \
                                                                  \
        dLRect.left = LBase.X - s[4]*L/2; dLRect.top = LBase.Y - s[4]*L/2;      \
        dLRect.right= LBase.X + s[4]*L/2; dLRect.bottom = LBase.Y + s[4]*L/2;   \
        dRRect.left = RBase.X - s[4]*L/2; dRRect.top = RBase.Y - s[4]*L/2;      \
        dRRect.right= RBase.X + s[4]*L/2; dRRect.bottom = RBase.Y + s[4]*L/2;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \


#define DRAW_EYE_AREA(v)  \
    awpImage* pCopy = NULL;                                       \
    if (awpCopyImage(image.GetImage(), &amp;pCopy) == AWP_OK)         \
    {                                                             \
        awpRect dLRect;                                           \
        awpRect dRRect;                                           \
        dLRect.left = LBase.X - W; dLRect.top = LBase.Y - W;      \
        dLRect.right= LBase.X + W; dLRect.bottom = LBase.Y + W;   \
        dRRect.left = RBase.X - W; dRRect.top = RBase.Y - W;      \
        dRRect.right= RBase.X + W; dRRect.bottom = RBase.Y + W;   \
                                                                  \
        awpDrawRect(pCopy, &amp;dLRect, 0, 128);                      \
        awpDrawRect(pCopy, &amp;dRRect, 0, 128);                      \
        if (v)                                                    \
          DRAW_EYE_CLIP_RECTS                                     \
        awpSaveImage(&quot;eye_area.jpg&quot; , pCopy);                     \
        awpReleaseImage(&amp;pCopy);                                  \
    }                                                             \



// реализация мозаики
TLFMosaic::TLFMosaic()
{
    m_pImage = NULL;

    m_NumCol = 4;
    m_NumRow = 4;

    m_ElWidth = 16;
    m_ElHeight = 16;

    m_dx = 0;
    m_dy = 0;

    CreateMosaic();
}

TLFMosaic::TLFMosaic(int NumCol, int NumRow, int W0, int H0, int dx, int dy)
{
    m_pImage = NULL;

    m_NumCol = NumCol;
    m_NumRow = NumRow;

    m_ElWidth = W0;
    m_ElHeight = H0;

    m_dx = dx;
    m_dy = dy;

    CreateMosaic();
}
TLFMosaic::~TLFMosaic()
{
    if (m_pImage)
        awpReleaseImage (&amp;m_pImage);
}
bool TLFMosaic::AddElement(int col, int row, awpImage* pImage)
{
    // преобразование изображения
    if (pImage == NULL)
        return false;
    if (pImage-&gt;bChannels != 1)
        return false;
    if (pImage-&gt;dwType != AWP_BYTE)
        return false;

    awpResize(pImage, m_ElWidth, m_ElHeight);

    awpPoint p;
    p.X = m_dx + col*(m_ElWidth + m_dx);
    p.Y = m_dy + row*(m_ElHeight + m_dy);

    return awpPasteRect(pImage, m_pImage, p) == AWP_OK;
}
// сохранение мозаики на диск
bool TLFMosaic::SaveMosaic(const char* lpFileName)
{
    if (m_pImage)
        return awpSaveImage(lpFileName, m_pImage) == AWP_OK;
    else
        return false;
}

void TLFMosaic::CreateMosaic()
{
   int ImageWidth  = 0;
   int ImageHeight = 0;

   ImageWidth  = m_dx + m_NumCol*(m_ElWidth + m_dx);
   ImageHeight = m_dy + m_NumRow*(m_ElHeight + m_dy);

   awpCreateImage(&amp;m_pImage, ImageWidth, ImageHeight, 1, AWP_BYTE);
}
// добавление изображения глаза в мозаику
#define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">// который содержит один столбец данных -</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">// значаения пикселей</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> _SaveAWPAsDAT(<span class="keyword">const</span> <span class="keywordtype">char</span>* lpFileName, awpImage* pImage)</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;{</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;   <span class="keywordflow">if</span> (pImage == NULL || lpFileName == NULL)</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;   <span class="keywordflow">switch</span> (pImage-&gt;dwType)</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;   {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      <span class="keywordflow">case</span> AWP_BYTE:</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">return</span> _bSaveAWPAsDAT(lpFileName, pImage);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;   }</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;}</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">// отрисовка области поиска глаз на копии входного изображения</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">// и сохраниение копии под именем eye_area.jpg</span></div>
<div class="line"><a name="l00125"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#aefc4d5554eb61a452712254b52a03b9b">  125</a></span>&#160;<span class="preprocessor">#define DRAW_EYE_CLIP_RECTS                                                   \</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="preprocessor">        dLRect.left = LBase.X - s[0]*L/2; dLRect.top = LBase.Y - s[0]*L/2;      \</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="preprocessor">        dLRect.right= LBase.X + s[0]*L/2; dLRect.bottom = LBase.Y + s[0]*L/2;   \</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="preprocessor">        dRRect.left = RBase.X - s[0]*L/2; dRRect.top = RBase.Y - s[0]*L/2;      \</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="preprocessor">        dRRect.right= RBase.X + s[0]*L/2; dRRect.bottom = RBase.Y + s[0]*L/2;   \</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="preprocessor">        dLRect.left = LBase.X - s[1]*L/2; dLRect.top = LBase.Y - s[1]*L/2;      \</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="preprocessor">        dLRect.right= LBase.X + s[1]*L/2; dLRect.bottom = LBase.Y + s[1]*L/2;   \</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="preprocessor">        dRRect.left = RBase.X - s[1]*L/2; dRRect.top = RBase.Y - s[1]*L/2;      \</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="preprocessor">        dRRect.right= RBase.X + s[1]*L/2; dRRect.bottom = RBase.Y + s[1]*L/2;   \</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="preprocessor">        dLRect.left = LBase.X - s[2]*L/2; dLRect.top = LBase.Y - s[2]*L/2;      \</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="preprocessor">        dLRect.right= LBase.X + s[2]*L/2; dLRect.bottom = LBase.Y + s[2]*L/2;   \</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="preprocessor">        dRRect.left = RBase.X - s[2]*L/2; dRRect.top = RBase.Y - s[2]*L/2;      \</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="preprocessor">        dRRect.right= RBase.X + s[2]*L/2; dRRect.bottom = RBase.Y + s[2]*L/2;   \</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="preprocessor">        dLRect.left = LBase.X - s[3]*L/2; dLRect.top = LBase.Y - s[3]*L/2;      \</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="preprocessor">        dLRect.right= LBase.X + s[3]*L/2; dLRect.bottom = LBase.Y + s[3]*L/2;   \</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="preprocessor">        dRRect.left = RBase.X - s[3]*L/2; dRRect.top = RBase.Y - s[3]*L/2;      \</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="preprocessor">        dRRect.right= RBase.X + s[3]*L/2; dRRect.bottom = RBase.Y + s[3]*L/2;   \</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="preprocessor">        dLRect.left = LBase.X - s[4]*L/2; dLRect.top = LBase.Y - s[4]*L/2;      \</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="preprocessor">        dLRect.right= LBase.X + s[4]*L/2; dLRect.bottom = LBase.Y + s[4]*L/2;   \</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="preprocessor">        dRRect.left = RBase.X - s[4]*L/2; dRRect.top = RBase.Y - s[4]*L/2;      \</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="preprocessor">        dRRect.right= RBase.X + s[4]*L/2; dRRect.bottom = RBase.Y + s[4]*L/2;   \</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dLRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dRRect, 0, 200);                      \</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="preprocessor"></span> </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160; </div>
<div class="line"><a name="l00167"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#a579c1ba6a4b0ad89bf46e215006c9bc3">  167</a></span>&#160;<span class="preprocessor">#define DRAW_EYE_AREA(v)  \</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="preprocessor">    awpImage* pCopy = NULL;                                       \</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="preprocessor">    if (awpCopyImage(image.GetImage(), &amp;pCopy) == AWP_OK)         \</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="preprocessor">    {                                                             \</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="preprocessor">        awpRect dLRect;                                           \</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="preprocessor">        awpRect dRRect;                                           \</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="preprocessor">        dLRect.left = LBase.X - W; dLRect.top = LBase.Y - W;      \</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="preprocessor">        dLRect.right= LBase.X + W; dLRect.bottom = LBase.Y + W;   \</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="preprocessor">        dRRect.left = RBase.X - W; dRRect.top = RBase.Y - W;      \</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="preprocessor">        dRRect.right= RBase.X + W; dRRect.bottom = RBase.Y + W;   \</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="preprocessor">                                                                  \</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dLRect, 0, 128);                      \</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="preprocessor">        awpDrawRect(pCopy, &amp;dRRect, 0, 128);                      \</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="preprocessor">        if (v)                                                    \</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="preprocessor">          DRAW_EYE_CLIP_RECTS                                     \</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="preprocessor">        awpSaveImage(&quot;eye_area.jpg&quot; , pCopy);                     \</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="preprocessor">        awpReleaseImage(&amp;pCopy);                                  \</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="preprocessor">    }                                                             \</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="preprocessor"></span> </div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160; </div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160; </div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">// реализация мозаики TLFMosaic::TLFMosaic()
{
    m_pImage = NULL;

    m_NumCol = 4;
    m_NumRow = 4;

    m_ElWidth = 16;
    m_ElHeight = 16;

    m_dx = 0;
    m_dy = 0;

    CreateMosaic();
}

TLFMosaic::TLFMosaic(int NumCol, int NumRow, int W0, int H0, int dx, int dy)
{
    m_pImage = NULL;

    m_NumCol = NumCol;
    m_NumRow = NumRow;

    m_ElWidth = W0;
    m_ElHeight = H0;

    m_dx = dx;
    m_dy = dy;

    CreateMosaic();
}
TLFMosaic::~TLFMosaic()
{
    if (m_pImage)
        awpReleaseImage (&amp;m_pImage);
}
bool TLFMosaic::AddElement(int col, int row, awpImage* pImage)
{
    // преобразование изображения
    if (pImage == NULL)
        return false;
    if (pImage-&gt;bChannels != 1)
        return false;
    if (pImage-&gt;dwType != AWP_BYTE)
        return false;

    awpResize(pImage, m_ElWidth, m_ElHeight);

    awpPoint p;
    p.X = m_dx + col*(m_ElWidth + m_dx);
    p.Y = m_dy + row*(m_ElHeight + m_dy);

    return awpPasteRect(pImage, m_pImage, p) == AWP_OK;
}
// сохранение мозаики на диск
bool TLFMosaic::SaveMosaic(const char* lpFileName)
{
    if (m_pImage)
        return awpSaveImage(lpFileName, m_pImage) == AWP_OK;
    else
        return false;
}

void TLFMosaic::CreateMosaic()
{
   int ImageWidth  = 0;
   int ImageHeight = 0;

   ImageWidth  = m_dx + m_NumCol*(m_ElWidth + m_dx);
   ImageHeight = m_dy + m_NumRow*(m_ElHeight + m_dy);

   awpCreateImage(&amp;m_pImage, ImageWidth, ImageHeight, 1, AWP_BYTE);
}
// добавление изображения глаза в мозаику
#define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00189"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#ad586648a59c911f98d869e9caeeaef1b">  189</a></span>&#160;<a class="code" href="class_t_l_f_mosaic.html#ad586648a59c911f98d869e9caeeaef1b">TLFMosaic::TLFMosaic</a>()</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;{</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a> = NULL;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160; </div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a08af8e3d00915acfc7ff7cb0884161be">m_NumCol</a> = 4;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#aa768306206ff35d9ef36ad4eb84b0050">m_NumRow</a> = 4;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160; </div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">m_ElWidth</a> = 16;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">m_ElHeight</a> = 16;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160; </div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">m_dx</a> = 0;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">m_dy</a> = 0;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160; </div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#aae2664cb9766ddb80ee09be2bc84a5a3">CreateMosaic</a>();</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160; </div>
<div class="line"><a name="l00205"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#a2d5f717bd6ead42702e2ea475b9c493c">  205</a></span>&#160;<a class="code" href="class_t_l_f_mosaic.html#ad586648a59c911f98d869e9caeeaef1b">TLFMosaic::TLFMosaic</a>(<span class="keywordtype">int</span> NumCol, <span class="keywordtype">int</span> NumRow, <span class="keywordtype">int</span> W0, <span class="keywordtype">int</span> H0, <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy)</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;{</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a> = NULL;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160; </div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a08af8e3d00915acfc7ff7cb0884161be">m_NumCol</a> = NumCol;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#aa768306206ff35d9ef36ad4eb84b0050">m_NumRow</a> = NumRow;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160; </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">m_ElWidth</a> = W0;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">m_ElHeight</a> = H0;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160; </div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">m_dx</a> = dx;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">m_dy</a> = dy;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160; </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <a class="code" href="class_t_l_f_mosaic.html#aae2664cb9766ddb80ee09be2bc84a5a3">CreateMosaic</a>();</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;}</div>
<div class="line"><a name="l00220"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#ae5a3ccd113908b52c8b4d5042c965a09">  220</a></span>&#160;<a class="code" href="class_t_l_f_mosaic.html#ae5a3ccd113908b52c8b4d5042c965a09">TLFMosaic::~TLFMosaic</a>()</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;{</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a>)</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        awpReleaseImage (&amp;<a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a>);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
<div class="line"><a name="l00225"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#a01bfd8a0b1f59be2fa7d9357dc61b522">  225</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="class_t_l_f_mosaic.html#a01bfd8a0b1f59be2fa7d9357dc61b522">TLFMosaic::AddElement</a>(<span class="keywordtype">int</span> col, <span class="keywordtype">int</span> row, awpImage* pImage)</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;{</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="comment">// преобразование изображения</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="keywordflow">if</span> (pImage == NULL)</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keywordflow">if</span> (pImage-&gt;bChannels != 1)</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">if</span> (pImage-&gt;dwType != AWP_BYTE)</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160; </div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    awpResize(pImage, <a class="code" href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">m_ElWidth</a>, <a class="code" href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">m_ElHeight</a>);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160; </div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    awpPoint p;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    p.X = <a class="code" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">m_dx</a> + col*(<a class="code" href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">m_ElWidth</a> + <a class="code" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">m_dx</a>);</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    p.Y = <a class="code" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">m_dy</a> + row*(<a class="code" href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">m_ElHeight</a> + <a class="code" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">m_dy</a>);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160; </div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="keywordflow">return</span> awpPasteRect(pImage, <a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a>, p) == AWP_OK;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;}</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">// сохранение мозаики на диск</span></div>
<div class="line"><a name="l00244"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#a87fddd0efef4d4f0b7a2b7f89b7df45e">  244</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="class_t_l_f_mosaic.html#a87fddd0efef4d4f0b7a2b7f89b7df45e">TLFMosaic::SaveMosaic</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* lpFileName)</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;{</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a>)</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="keywordflow">return</span> awpSaveImage(lpFileName, <a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a>) == AWP_OK;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;}</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160; </div>
<div class="line"><a name="l00252"></a><span class="lineno"><a class="line" href="class_t_l_f_mosaic.html#aae2664cb9766ddb80ee09be2bc84a5a3">  252</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="class_t_l_f_mosaic.html#aae2664cb9766ddb80ee09be2bc84a5a3">TLFMosaic::CreateMosaic</a>()</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;{</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;   <span class="keywordtype">int</span> ImageWidth  = 0;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;   <span class="keywordtype">int</span> ImageHeight = 0;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160; </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;   ImageWidth  = <a class="code" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">m_dx</a> + <a class="code" href="class_t_l_f_mosaic.html#a08af8e3d00915acfc7ff7cb0884161be">m_NumCol</a>*(<a class="code" href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">m_ElWidth</a> + <a class="code" href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">m_dx</a>);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;   ImageHeight = <a class="code" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">m_dy</a> + <a class="code" href="class_t_l_f_mosaic.html#aa768306206ff35d9ef36ad4eb84b0050">m_NumRow</a>*(<a class="code" href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">m_ElHeight</a> + <a class="code" href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">m_dy</a>);</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160; </div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;   awpCreateImage(&amp;<a class="code" href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">m_pImage</a>, ImageWidth, ImageHeight, 1, AWP_BYTE);</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;}</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">// добавление изображения глаза в мозаику #define _ADD_TO_MOSAIC_                                                 \
    awpImage* pLImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \
    {                                                                   \
        LMosaic.AddElement(col, row, pLImage);                          \
        awpReleaseImage(&amp;pLImage);                                      \
    }                                                                   \
                                                                        \
    awpImage* pRImage = NULL;                                           \
    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \
    {                                                                   \
        RMosaic.AddElement(col, row, pRImage);                          \
        awpReleaseImage(&amp;pRImage);                                      \
    }                                                                   \
                                                                        \
    gCount++;                                                           \

//сохраняет мозаику на диск
#define _SAVE_MOSAIC_                                                   \
    char name[32];                                                      \
    memset(name, 0, sizeof(name));                                      \
    char* lmos = &quot;lm.jpg&quot;;                                              \
    char* rmos = &quot;rm.jpg&quot;;                                              \
    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \
    LMosaic.SaveMosaic(name);                                           \
    memset(name, 0, sizeof(name));                                      \
    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \
    RMosaic.SaveMosaic(name);


///////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye
// для набора прямоугольных фрагментов.
//
TLFRoi* ILFEye::Precise(TLFImage&amp; image, TLFRoi&amp; roi, LFPreciseMethod Method)
{
  TLFRoi* pLFRoi = NULL;
  //изображение на которм уточняются глаза
  awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00263"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#a76e5b085c545efdcce49c6867c53b9d9">  263</a></span>&#160;<span class="preprocessor">#define _ADD_TO_MOSAIC_                                                 \</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="preprocessor">    awpImage* pLImage = NULL;                                           \</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="preprocessor">    if (awpCopyRect(image.GetImage(), &amp;pLImage, &amp;LRect) == AWP_OK)      \</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="preprocessor">    {                                                                   \</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="preprocessor">        LMosaic.AddElement(col, row, pLImage);                          \</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="preprocessor">        awpReleaseImage(&amp;pLImage);                                      \</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="preprocessor">    }                                                                   \</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="preprocessor">                                                                        \</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="preprocessor">    awpImage* pRImage = NULL;                                           \</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="preprocessor">    if (awpCopyRect(image.GetImage(), &amp;pRImage, &amp;RRect) == AWP_OK)      \</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="preprocessor">    {                                                                   \</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="preprocessor">        RMosaic.AddElement(col, row, pRImage);                          \</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="preprocessor">        awpReleaseImage(&amp;pRImage);                                      \</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="preprocessor">    }                                                                   \</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="preprocessor">                                                                        \</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="preprocessor">    gCount++;                                                           \</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="preprocessor"></span> </div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">//сохраняет мозаику на диск</span></div>
<div class="line"><a name="l00281"></a><span class="lineno"><a class="line" href="_l_f_eye_8cpp.html#a2c2cc15a1f0e7b288620d3d4c780b0f8">  281</a></span>&#160;<span class="preprocessor">#define _SAVE_MOSAIC_                                                   \</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="preprocessor">    char name[32];                                                      \</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="preprocessor">    memset(name, 0, sizeof(name));                                      \</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="preprocessor">    char* lmos = &quot;lm.jpg&quot;;                                              \</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="preprocessor">    char* rmos = &quot;rm.jpg&quot;;                                              \</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="preprocessor">    sprintf(name, &quot;%i%s&quot;, m, lmos);                                     \</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="preprocessor">    LMosaic.SaveMosaic(name);                                           \</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="preprocessor">    memset(name, 0, sizeof(name));                                      \</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="preprocessor">    sprintf(name, &quot;%i%s&quot;, m, rmos);                                     \</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="preprocessor">    RMosaic.SaveMosaic(name);</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160; </div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160; </div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">// Уточнение местоположения глаза. Вызывает виртуальную функцию  CheckEye</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">// для набора прямоугольных фрагментов.</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00297"></a><span class="lineno"><a class="line" href="class_i_l_f_eye.html#a5d4b93166c4b25d2da0421a1b4fd54ab">  297</a></span>&#160;<a class="code" href="class_t_l_f_roi.html">TLFRoi</a>* <a class="code" href="class_i_l_f_eye.html#a5d4b93166c4b25d2da0421a1b4fd54ab">ILFEye::Precise</a>(<a class="code" href="class_t_l_f_image.html">TLFImage</a>&amp; image, <a class="code" href="class_t_l_f_roi.html">TLFRoi</a>&amp; roi, <a class="code" href="group___l_f_descriptors.html#ga4ade4d13955504def49f007e5f785cf6">LFPreciseMethod</a> Method)</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;{</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <a class="code" href="class_t_l_f_roi.html">TLFRoi</a>* pLFRoi = NULL;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  <span class="comment">//изображение на которм уточняются глаза   awpImage* img =  image.GetImage();
  if (img == NULL)
        return pLFRoi;
  double lerr, rerr;
  // расстояние между глазами
  TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  awpImage* img =  image.<a class="code" href="class_t_l_f_image.html#a5a44ea86ac3f94f530665d047f95cc69">GetImage</a>();</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  <span class="keywordflow">if</span> (img == NULL)</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">return</span> pLFRoi;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  <span class="keywordtype">double</span> lerr, rerr;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  <span class="comment">// расстояние между глазами   TROI troi = roi.GetRoi();
  double L = troi.EyeDistance();
  // ширина прямоугольника, в котором будет оцениваться наличие глаза
  int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <a class="code" href="structtag_rect_of_interst.html">TROI</a> troi = roi.<a class="code" href="class_t_l_f_roi.html#a00f69e12106a1652d2f07c5c44bd4c57">GetRoi</a>();</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  <span class="keywordtype">double</span> L = troi.<a class="code" href="structtag_rect_of_interst.html#a971f9919e08cbef413b61c1700ff0695">EyeDistance</a>();</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  <span class="comment">// ширина прямоугольника, в котором будет оцениваться наличие глаза   int    W   =    int(L/3);
  int    WW  =    int(0.75*L);
  int    step = int(L/16);
  if (step == 0) step = 1;
  double  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};

  // базовые точки вокруг которых выполняется поиск
  awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="keywordtype">int</span>    W   =    int(L/3);</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="keywordtype">int</span>    WW  =    int(0.75*L);</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  <span class="keywordtype">int</span>    step = int(L/16);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="keywordflow">if</span> (step == 0) step = 1;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="keywordtype">double</span>  s[5] = {0.5, 0.65, 0.75, 0.85, 0.95};</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160; </div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="comment">// базовые точки вокруг которых выполняется поиск   awpPoint LBase;LBase = troi.p;
  awpPoint RBase;RBase = troi.p1;

  awpRect LRect;
  awpRect RRect;

  //цикл, выполняющий детектирование глаз
  int x,y,x1, y1;
  double sx  = 0;
  double sy  = 0;
  double sx1 = 0;
  double sy1 = 0;
  double mx  = 0;
  double my  = 0;
  double mx1 = 0;
  double my1 = 0;
  double sm  = 0;
  double sm1 = 0;

  int count  = 0;
  int count1 = 0;

  bool LFound = false;
  bool RFound = false;

#ifdef _SDEBUG
    gCount = 0;

    // создание файлов отладочной информации
    // файл отладочной информации Xeye_dist.dat содержит три
    // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  awpPoint LBase;LBase = troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  awpPoint RBase;RBase = troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160; </div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  awpRect LRect;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  awpRect RRect;</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160; </div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  <span class="comment">//цикл, выполняющий детектирование глаз</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  <span class="keywordtype">int</span> x,y,x1, y1;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  <span class="keywordtype">double</span> sx  = 0;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="keywordtype">double</span> sy  = 0;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <span class="keywordtype">double</span> sx1 = 0;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  <span class="keywordtype">double</span> sy1 = 0;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="keywordtype">double</span> mx  = 0;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  <span class="keywordtype">double</span> my  = 0;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  <span class="keywordtype">double</span> mx1 = 0;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  <span class="keywordtype">double</span> my1 = 0;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="keywordtype">double</span> sm  = 0;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  <span class="keywordtype">double</span> sm1 = 0;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160; </div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  <span class="keywordtype">int</span> count  = 0;</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  <span class="keywordtype">int</span> count1 = 0;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160; </div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  <span class="keywordtype">bool</span> LFound = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  <span class="keywordtype">bool</span> RFound = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160; </div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    gCount = 0;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160; </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="comment">// создание файлов отладочной информации</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="comment">// файл отладочной информации Xeye_dist.dat содержит три     // текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]
    FILE* FL = fopen(&quot;leye_dist.dat&quot;, &quot;w+t&quot;);
    FILE* FR = fopen(&quot;reye_dist.dat&quot;, &quot;w+t&quot;);

    DRAW_EYE_AREA(false)
#endif

  bool  CheckLResult = false; // результат проверки наличия глаза в точке.
  bool  CheckRResult = false; // результат проверки наличия глаза в точке.
  double flmax       = -1;
  double frmax       = -1;
  for (int m = 0; m &lt; 4; m++)
  {

#ifdef _SDEBUG
   int M = 2*W / step;
   int N = 2*W / step;
   TLFMosaic LMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
   TLFMosaic RMosaic(M, N, c_nEyeWidth, c_nEyeHeight, 1, 1);
#endif

  WW = int(s[m]*L);
  int row,col;
  for ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)
  {
        for ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)
        {
           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;
           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;

           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;
           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;

           if (awpRectInImage(img, &amp;LRect) != AWP_OK)
             continue;

           if (awpRectInImage(img, &amp;RRect) != AWP_OK)
             continue;
#ifdef _SDEBUG
          _ADD_TO_MOSAIC_
#endif
           CheckLResult = CheckEye(LRect, img, lerr, LFLeftEye);

#ifdef _SDEBUG
            gCount++;
#endif
           CheckRResult = CheckEye(RRect, img, rerr, LFRightEye);

           if (Method == LFAverage)
           {
              if (CheckLResult)
              {
                sx += x;
                sy += y;
                count++;
                LFound = true;
              }
              if (CheckRResult)
              {
                sx1 += x1;
                sy1 += y1;
                count1++;
                RFound = true;
              }
           }
           else if (Method == LFExtremum)
           {
              LFound = true;
              RFound = true;
              if (flmax &lt; lerr)
              {
                flmax = lerr;
                sx = x;
                sy = y;
                count = 1;
              }

              if (frmax &lt; rerr)
              {
                frmax = rerr;
                sx1 = x1;
                sy1 = y1;
                count1 = 1;
              }
           }
           else if (Method == LFMean)
           {
               if (CheckLResult)
               {
                 mx = mx + (1+lerr)*x;
                 my = my + (1+lerr)*y;
                 sm +=(1+lerr);
                 LFound = true;
               }
               if (CheckRResult)
               {
                   mx1 += (1+rerr)*x1;
                   my1 += (1+rerr)*y1;
                   sm1 +=(1+rerr);
                   RFound = true;
               }
           }

#ifdef _SDEBUG
    fprintf(FL, &quot;%i\t%i\t%f\n&quot;, x,y, lerr);
    fprintf(FR, &quot;%i\t%i\t%f\n&quot;, x1,y1, rerr);
#endif
        }
  }
#ifdef _SDEBUG
            _SAVE_MOSAIC_
#endif
  }
  // выполним уточнение
  //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="comment">// текстовых столбца: [x-координата], [у-координата], [расстояние до эталона]</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    FILE* FL = fopen(<span class="stringliteral">&quot;leye_dist.dat&quot;</span>, <span class="stringliteral">&quot;w+t&quot;</span>);</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    FILE* FR = fopen(<span class="stringliteral">&quot;reye_dist.dat&quot;</span>, <span class="stringliteral">&quot;w+t&quot;</span>);</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160; </div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <a class="code" href="_l_f_eye_8cpp.html#a579c1ba6a4b0ad89bf46e215006c9bc3">DRAW_EYE_AREA</a>(<span class="keyword">false</span>)</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160; </div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="keywordtype">bool</span>  CheckLResult = <span class="keyword">false</span>; <span class="comment">// результат проверки наличия глаза в точке.</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  <span class="keywordtype">bool</span>  CheckRResult = <span class="keyword">false</span>; <span class="comment">// результат проверки наличия глаза в точке.</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  <span class="keywordtype">double</span> flmax       = -1;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <span class="keywordtype">double</span> frmax       = -1;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m = 0; m &lt; 4; m++)</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  {</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;   <span class="keywordtype">int</span> M = 2*W / step;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;   <span class="keywordtype">int</span> N = 2*W / step;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;   <a class="code" href="class_t_l_f_mosaic.html">TLFMosaic</a> LMosaic(M, N, <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>, <a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a>, 1, 1);</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;   <a class="code" href="class_t_l_f_mosaic.html">TLFMosaic</a> RMosaic(M, N, <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>, <a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a>, 1, 1);</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160; </div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  WW = int(s[m]*L);</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  <span class="keywordtype">int</span> row,col;</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  <span class="keywordflow">for</span> ( y = LBase.Y - W, y1 = RBase.Y - W,  row = 0; y &lt; LBase.Y + W; y += step, y1 += step, row++)</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  {</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        <span class="keywordflow">for</span> ( x = LBase.X - W, x1 = RBase.X - W,  col = 0; x &lt; LBase.X + W; x += step, x1 += step, col++)</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;           LRect.left  = x - WW / 2; LRect.top = y - WW / 2;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;           LRect.right = x + WW / 2; LRect.bottom = y + WW /2;</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160; </div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;           RRect.left  = x1 - WW /2; RRect.top = y1 - WW/2;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;           RRect.right = x1 + WW/2;  RRect.bottom = y1 + WW/2;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160; </div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;           <span class="keywordflow">if</span> (awpRectInImage(img, &amp;LRect) != AWP_OK)</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;             <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160; </div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;           <span class="keywordflow">if</span> (awpRectInImage(img, &amp;RRect) != AWP_OK)</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;             <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;          <a class="code" href="_l_f_eye_8cpp.html#a76e5b085c545efdcce49c6867c53b9d9">_ADD_TO_MOSAIC_</a></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;           CheckLResult = <a class="code" href="class_i_l_f_eye.html#a3fc11a6ebbf309a5fa3c8c4714506009">CheckEye</a>(LRect, img, lerr, <a class="code" href="group___l_f_descriptors.html#gga7bba2c5e592fb982d240d5ee4235e9a6a87b49f04c2fe5b7bb932afc29812e776">LFLeftEye</a>);</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160; </div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            gCount++;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;           CheckRResult = <a class="code" href="class_i_l_f_eye.html#a3fc11a6ebbf309a5fa3c8c4714506009">CheckEye</a>(RRect, img, rerr, <a class="code" href="group___l_f_descriptors.html#gga7bba2c5e592fb982d240d5ee4235e9a6ad87d3473a238ac53b858d9fcfd0f5fb1">LFRightEye</a>);</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160; </div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;           <span class="keywordflow">if</span> (Method == <a class="code" href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a64eb1073ca403f58988b3842c6c42eee">LFAverage</a>)</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;           {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;              <span class="keywordflow">if</span> (CheckLResult)</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;              {</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                sx += x;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                sy += y;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                count++;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                LFound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;              }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;              <span class="keywordflow">if</span> (CheckRResult)</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;              {</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                sx1 += x1;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                sy1 += y1;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                count1++;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                RFound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;              }</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;           }</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Method == <a class="code" href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a737034a2cfb9e73149c0f408d397cc5f">LFExtremum</a>)</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;           {</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;              LFound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;              RFound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;              <span class="keywordflow">if</span> (flmax &lt; lerr)</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;              {</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                flmax = lerr;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                sx = x;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                sy = y;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                count = 1;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;              }</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160; </div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;              <span class="keywordflow">if</span> (frmax &lt; rerr)</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;              {</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                frmax = rerr;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                sx1 = x1;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                sy1 = y1;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                count1 = 1;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;              }</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;           }</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Method == <a class="code" href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a6a93363c3c6ca2c5fdcb68a6a08ecf12">LFMean</a>)</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;           {</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;               <span class="keywordflow">if</span> (CheckLResult)</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;               {</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                 mx = mx + (1+lerr)*x;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                 my = my + (1+lerr)*y;</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                 sm +=(1+lerr);</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                 LFound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;               }</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;               <span class="keywordflow">if</span> (CheckRResult)</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;               {</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                   mx1 += (1+rerr)*x1;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                   my1 += (1+rerr)*y1;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                   sm1 +=(1+rerr);</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                   RFound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;               }</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;           }</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160; </div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    fprintf(FL, <span class="stringliteral">&quot;%i\t%i\t%f\n&quot;</span>, x,y, lerr);</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    fprintf(FR, <span class="stringliteral">&quot;%i\t%i\t%f\n&quot;</span>, x1,y1, rerr);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        }</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  }</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            <a class="code" href="_l_f_eye_8cpp.html#a2c2cc15a1f0e7b288620d3d4c780b0f8">_SAVE_MOSAIC_</a></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  }</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <span class="comment">// выполним уточнение   //awpPoint p, p1; // новое местоположение глаз
  switch (Method)
  {
    case LFAverage:
        troi.p.X = count == 0? troi.p.X: AWPSHORT(sx / count);
        troi.p.Y = count == 0? troi.p.Y: AWPSHORT(sy / count);
        troi.p1.X = count1 == 0? troi.p1.X: AWPSHORT(sx1 / count1);
        troi.p1.Y = count1 == 0? troi.p1.Y: AWPSHORT(sy1 / count1);
    break;
    case LFExtremum:
        troi.p.X = AWPSHORT(sx);
        troi.p.Y = AWPSHORT(sy);
        troi.p1.X = AWPSHORT(sx1);
        troi.p1.Y = AWPSHORT(sy1);
    break;
    case LFMean:
        troi.p.X  = sm != 0? AWPSHORT(mx / sm): troi.p.X;
        troi.p.Y  = sm != 0? AWPSHORT(my / sm): troi.p.Y;
        troi.p1.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.p1.X;
        troi.p1.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.p1.Y;
    break;
  }
  pLFRoi = new TLFRoi();
  troi.err[2] = LFound?1:0;
  troi.err[3] = RFound?1:0;
  pLFRoi-&gt;SetRoi(troi);

#ifdef _SDEBUG
    fclose(FL);
    fclose(FR);
#endif

  return pLFRoi;
}
////////////////////////////////////////////////////////////////////////////////
// Уточнение местоположения глаз методом сравнения исследуемого прямогольника
// со усредненным изображением глаза
TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  <span class="comment">//awpPoint p, p1; // новое местоположение глаз</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  <span class="keywordflow">switch</span> (Method)</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  {</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a64eb1073ca403f58988b3842c6c42eee">LFAverage</a>:</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.X = count == 0? troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.X: AWPSHORT(sx / count);</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.Y = count == 0? troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.Y: AWPSHORT(sy / count);</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.X = count1 == 0? troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.X: AWPSHORT(sx1 / count1);</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.Y = count1 == 0? troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.Y: AWPSHORT(sy1 / count1);</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a737034a2cfb9e73149c0f408d397cc5f">LFExtremum</a>:</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.X = AWPSHORT(sx);</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.Y = AWPSHORT(sy);</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.X = AWPSHORT(sx1);</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.Y = AWPSHORT(sy1);</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a6a93363c3c6ca2c5fdcb68a6a08ecf12">LFMean</a>:</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.X  = sm != 0? AWPSHORT(mx / sm): troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.X;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.Y  = sm != 0? AWPSHORT(my / sm): troi.<a class="code" href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">p</a>.Y;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.X = sm1 != 0? AWPSHORT(mx1 / sm1): troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.X;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.Y = sm1 != 0? AWPSHORT(my1 / sm1): troi.<a class="code" href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">p1</a>.Y;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  }</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  pLFRoi = <span class="keyword">new</span> <a class="code" href="class_t_l_f_roi.html">TLFRoi</a>();</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  troi.<a class="code" href="structtag_rect_of_interst.html#a69eb1255a6edb75158afa2d805365438">err</a>[2] = LFound?1:0;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  troi.<a class="code" href="structtag_rect_of_interst.html#a69eb1255a6edb75158afa2d805365438">err</a>[3] = RFound?1:0;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  pLFRoi-&gt;<a class="code" href="class_t_l_f_roi.html#a4dba8f6655344cad412d3d09d656a6fe">SetRoi</a>(troi);</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160; </div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    fclose(FL);</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    fclose(FR);</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160; </div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  <span class="keywordflow">return</span> pLFRoi;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;}</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">// Уточнение местоположения глаз методом сравнения исследуемого прямогольника</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">// со усредненным изображением глаза TLFEyeCorrelation::TLFEyeCorrelation()
{
    m_pLeftEye  = NULL;
    m_pRightEye = NULL;
}

bool TLFEyeCorrelation::Init(const char* lpInitString)
{
#ifdef _SDEBUG
// код для отладки. сохраняет изображение глаза на диск в формате jpg
//awpImage* dbg_img = NULL;
//awpCopyImage(imgLeftEye, &amp;dbg_img);
//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);
//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);
//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);
//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);
//awpReleaseImage(&amp;dbg_img);
#endif

  char* chName = NULL;
  const char* chLEye  = &quot;left_eye7512.awp&quot;;
  const char* chREye  = &quot;right_eye7512.awp&quot;;
  chName = (char*)malloc(strlen(lpInitString) + strlen(chREye) + 2);
  memset(chName, 0, strlen(lpInitString) + strlen(chREye));
  memcpy(chName, lpInitString, strlen(lpInitString));
  chName = strcat(chName, chLEye);
  if (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)
  {
        //для того, чтобы выполнить операцию поворота изображение должно иметь
        //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00497"></a><span class="lineno"><a class="line" href="class_t_l_f_eye_correlation.html#a09992dbb07140d031f32743acd6b61cc">  497</a></span>&#160;<a class="code" href="class_t_l_f_eye_correlation.html#a09992dbb07140d031f32743acd6b61cc">TLFEyeCorrelation::TLFEyeCorrelation</a>()</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;{</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    m_pLeftEye  = NULL;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    m_pRightEye = NULL;</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;}</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160; </div>
<div class="line"><a name="l00503"></a><span class="lineno"><a class="line" href="class_t_l_f_eye_correlation.html#ae975afa3bab25c7745347b90bae77b50">  503</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="class_t_l_f_eye_correlation.html#ae975afa3bab25c7745347b90bae77b50">TLFEyeCorrelation::Init</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* lpInitString)</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;{</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="comment">// код для отладки. сохраняет изображение глаза на диск в формате jpg</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="comment">//awpImage* dbg_img = NULL;</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment">//awpCopyImage(imgLeftEye, &amp;dbg_img);</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">//awpConvert(dbg_img, AWP_CONVERT_TO_BYTE_WITH_NORM);</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment">//awpSaveImage(&quot;left_eye.jpg&quot;, dbg_img);</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment">//_SaveAWPAsXYZ(&quot;left_eye.xyz&quot;, dbg_img);</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">//_SaveAWPAsDAT(&quot;left_eye.dat&quot;, dbg_img);</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">//awpReleaseImage(&amp;dbg_img);</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160; </div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  <span class="keywordtype">char</span>* chName = NULL;</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span>* chLEye  = <span class="stringliteral">&quot;left_eye7512.awp&quot;</span>;</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span>* chREye  = <span class="stringliteral">&quot;right_eye7512.awp&quot;</span>;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;  chName = (<span class="keywordtype">char</span>*)malloc(strlen(lpInitString) + strlen(chREye) + 2);</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;  memset(chName, 0, strlen(lpInitString) + strlen(chREye));</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;  memcpy(chName, lpInitString, strlen(lpInitString));</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;  chName = strcat(chName, chLEye);</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;  <span class="keywordflow">if</span> (awpLoadImage(chName, &amp;m_pLeftEye) == AWP_OK)</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  {</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        <span class="comment">//для того, чтобы выполнить операцию поворота изображение должно иметь         //тип AWP_BYTE
        if (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)
        {
           memset(chName, 0, strlen(lpInitString) + strlen(chREye));
           memcpy(chName, lpInitString, strlen(lpInitString));
           chName = strcat(chName, chREye);

           //скопируем изображение imgLeft в изображение imgRight
           //и повернем последнее.
           if (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)
           {
              //выполним операцию поворота
              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);

              //вычислим среднюю интенсивность глаза.
              double avgl = 0;
              double displ = 0;
              double avgr = 0;
              double dispr = 0;
              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;
              for (int i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)
              {
                avgl += pixLeft[i];
                displ += pixLeft[i]*pixLeft[i];
                avgr += pixRight[i];
                dispr += pixRight[i]*pixRight[i];
              }

              displ = (c_nEyeSize*displ - avgl*avgl) / c_nEyeSize2;
              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;

              dispr = (c_nEyeSize*dispr - avgr*avgr) / c_nEyeSize2;
              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;

              m_fMathLeft = avgl;
              m_fDispLeft = sqrt(displ);

              m_fMathRight =  avgr;
              m_fDispRight =  sqrt(dispr);

              m_IsInitialized = true;
           }
        }
  }
#ifdef _SDEBUG
awpSaveImage(&quot;wleft_eye.jpg&quot;,  m_pLeftEye);
awpSaveImage(&quot;wright_eye.jpg&quot;, m_pRightEye);
#endif
   free(chName);
   return m_IsInitialized;
}

TLFEyeCorrelation::~TLFEyeCorrelation()
{
    awpReleaseImage(&amp;m_pLeftEye);
    awpReleaseImage(&amp;m_pRightEye);
}

bool TLFEyeCorrelation::CheckEye(awpRect&amp; r, awpImage* pImage, double&amp; err, LFEyes eye)
{
    double feye[c_nEyeSize];
    
    double sx = (r.right - r.left) / (double)c_nEyeWidth;
    double sy = (r.bottom - r.top) / (double)c_nEyeHeight;

    int i, j , c;
    c = 0;
    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;
    for (int y = 0; y &lt; c_nEyeHeight; y++)
    {
        for (int x = 0; x &lt; c_nEyeWidth; x++)
        {
           i = int(r.left + x*sx);
           j = int(r.top  + y*sy);
           feye[c] = pix[j*pImage-&gt;sSizeX + i];
           c++;
        }
    }
#ifdef _SDEBUG
char strName[32];
sprintf(strName, &quot;%i%s&quot;, gCount, gExtJPG);
awpImage* dbg_img = NULL;
awpCreateImage(&amp;dbg_img, c_nEyeWidth, c_nEyeHeight, 1, AWP_BYTE);
BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;
for (int dbg_i = 0; dbg_i &lt; c_nEyeWidth*c_nEyeHeight; dbg_i++)
      dbg_pix[dbg_i] = feye[dbg_i];
//awpSaveImage(strName, dbg_img);
sprintf(strName, &quot;%i%s&quot;, gCount, gExtDAT);
//_SaveAWPAsDAT(strName, dbg_img);
awpReleaseImage(&amp;dbg_img);
#endif

    err = Correlation(feye, eye);
    return err &gt; c_fCorrThr;
}


double TLFEyeCorrelation::Correlation(double* TestVct, LFEyes eye)
{
  // характеристики исходного вектора
  AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        <span class="comment">//тип AWP_BYTE</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        <span class="keywordflow">if</span> (awpConvert(m_pLeftEye, AWP_CONVERT_TO_BYTE_WITH_NORM) == AWP_OK)</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;        {</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;           memset(chName, 0, strlen(lpInitString) + strlen(chREye));</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;           memcpy(chName, lpInitString, strlen(lpInitString));</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;           chName = strcat(chName, chREye);</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160; </div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;           <span class="comment">//скопируем изображение imgLeft в изображение imgRight</span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;           <span class="comment">//и повернем последнее.</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;           <span class="keywordflow">if</span> (awpLoadImage(chName, &amp;m_pRightEye) == AWP_OK)</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;           {</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;              <span class="comment">//выполним операцию поворота</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;              awpConvert(m_pRightEye, AWP_CONVERT_TO_BYTE_WITH_NORM);</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160; </div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;              <span class="comment">//вычислим среднюю интенсивность глаза.</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;              <span class="keywordtype">double</span> avgl = 0;</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;              <span class="keywordtype">double</span> displ = 0;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;              <span class="keywordtype">double</span> avgr = 0;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;              <span class="keywordtype">double</span> dispr = 0;</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;              AWPBYTE*  pixLeft = (AWPBYTE*)m_pLeftEye-&gt;pPixels;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;              AWPBYTE*  pixRight = (AWPBYTE*)m_pRightEye-&gt;pPixels;</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY; i++)</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;              {</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                avgl += pixLeft[i];</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                displ += pixLeft[i]*pixLeft[i];</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                avgr += pixRight[i];</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                dispr += pixRight[i]*pixRight[i];</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;              }</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160; </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;              displ = (<a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>*displ - avgl*avgl) / <a class="code" href="_l_f_eye_8cpp.html#ad3146f534a9e2c469fd3ad7430353e1d">c_nEyeSize2</a>;</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;              avgl /= m_pLeftEye-&gt;sSizeX*m_pLeftEye-&gt;sSizeY;</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160; </div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;              dispr = (<a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>*dispr - avgr*avgr) / <a class="code" href="_l_f_eye_8cpp.html#ad3146f534a9e2c469fd3ad7430353e1d">c_nEyeSize2</a>;</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;              avgr /= m_pRightEye-&gt;sSizeX*m_pRightEye-&gt;sSizeY;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160; </div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;              m_fMathLeft = avgl;</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;              m_fDispLeft = sqrt(displ);</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160; </div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;              m_fMathRight =  avgr;</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;              m_fDispRight =  sqrt(dispr);</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160; </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;              <a class="code" href="class_i_l_f_eye.html#aba4c3f7ddb16243272dc05489469911c">m_IsInitialized</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;           }</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        }</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  }</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;awpSaveImage(<span class="stringliteral">&quot;wleft_eye.jpg&quot;</span>,  m_pLeftEye);</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;awpSaveImage(<span class="stringliteral">&quot;wright_eye.jpg&quot;</span>, m_pRightEye);</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;   free(chName);</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;   <span class="keywordflow">return</span> <a class="code" href="class_i_l_f_eye.html#aba4c3f7ddb16243272dc05489469911c">m_IsInitialized</a>;</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;}</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160; </div>
<div class="line"><a name="l00579"></a><span class="lineno"><a class="line" href="class_t_l_f_eye_correlation.html#a449fd6f0cbcc0ce06181292ac3e266e5">  579</a></span>&#160;<a class="code" href="class_t_l_f_eye_correlation.html#a449fd6f0cbcc0ce06181292ac3e266e5">TLFEyeCorrelation::~TLFEyeCorrelation</a>()</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;{</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    awpReleaseImage(&amp;m_pLeftEye);</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    awpReleaseImage(&amp;m_pRightEye);</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;}</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160; </div>
<div class="line"><a name="l00585"></a><span class="lineno"><a class="line" href="class_t_l_f_eye_correlation.html#a7ea5ef63d7490f32fb273184048f8faf">  585</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="class_t_l_f_eye_correlation.html#a7ea5ef63d7490f32fb273184048f8faf">TLFEyeCorrelation::CheckEye</a>(awpRect&amp; r, awpImage* pImage, <span class="keywordtype">double</span>&amp; err, <a class="code" href="group___l_f_descriptors.html#ga7bba2c5e592fb982d240d5ee4235e9a6">LFEyes</a> eye)</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;{</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    <span class="keywordtype">double</span> feye[<a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>];</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    </div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <span class="keywordtype">double</span> sx = (r.right - r.left) / (<span class="keywordtype">double</span>)<a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="keywordtype">double</span> sy = (r.bottom - r.top) / (<span class="keywordtype">double</span>)<a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a>;</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160; </div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    <span class="keywordtype">int</span> i, j , c;</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    c = 0;</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    AWPBYTE* pix = (AWPBYTE*)pImage-&gt;pPixels;</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    for (<span class="keywordtype">int</span> y = 0; y &lt; <a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a>; y++)</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    {</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>; x++)</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        {</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;           i = int(r.left + x*sx);</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;           j = int(r.top  + y*sy);</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;           feye[c] = pix[j*pImage-&gt;sSizeX + i];</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;           c++;</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        }</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    }</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="preprocessor">#ifdef _SDEBUG</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="keywordtype">char</span> strName[32];</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;sprintf(strName, <span class="stringliteral">&quot;%i%s&quot;</span>, gCount, gExtJPG);</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;awpImage* dbg_img = NULL;</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;awpCreateImage(&amp;dbg_img, <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>, <a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a>, 1, AWP_BYTE);</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;BYTE* dbg_pix = (BYTE*)dbg_img-&gt;pPixels;</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;for (<span class="keywordtype">int</span> dbg_i = 0; dbg_i &lt; <a class="code" href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a>*<a class="code" href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a>; dbg_i++)</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;      dbg_pix[dbg_i] = feye[dbg_i];</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="comment">//awpSaveImage(strName, dbg_img);</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;sprintf(strName, <span class="stringliteral">&quot;%i%s&quot;</span>, gCount, gExtDAT);</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="comment">//_SaveAWPAsDAT(strName, dbg_img);</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;awpReleaseImage(&amp;dbg_img);</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160; </div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    err = Correlation(feye, eye);</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;    <span class="keywordflow">return</span> err &gt; <a class="code" href="_l_f_eye_8cpp.html#a614da9e44621b6c13ed31f9a312d49c6">c_fCorrThr</a>;</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;}</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160; </div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160; </div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="keywordtype">double</span> TLFEyeCorrelation::Correlation(<span class="keywordtype">double</span>* TestVct, <a class="code" href="group___l_f_descriptors.html#ga7bba2c5e592fb982d240d5ee4235e9a6">LFEyes</a> eye)</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;{</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  <span class="comment">// характеристики исходного вектора   AWPBYTE* SourceVct  = NULL; // исходный вектор
  double  SourceAvg = 0;    // матожидание для исходного вектора
  double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;  AWPBYTE* SourceVct  = NULL; <span class="comment">// исходный вектор</span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;  <span class="keywordtype">double</span>  SourceAvg = 0;    <span class="comment">// матожидание для исходного вектора   double  SourceDisp = 0;    // дисперсия для исходного вектора

  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  <span class="keywordtype">double</span>  SourceDisp = 0;    <span class="comment">// дисперсия для исходного вектора 
  // характеристики тестового вектора
  double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160; </div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;  <span class="comment">// характеристики тестового вектора   double TestAvg = 0;
  double TestDisp = 0;

  double cov = 0; // матожидание для результата

  if (eye == LFLeftEye)
  {
     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;
     SourceAvg  = m_fMathLeft;
     SourceDisp = m_fDispLeft;
  }
  else if (eye == LFRightEye)
  {
     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;
     SourceAvg  = m_fMathRight;
     SourceDisp = m_fDispRight;
  }


  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    TestAvg  += TestVct[i];
    TestDisp += TestVct[i]*TestVct[i];
  }

  TestDisp = sqrt((c_nEyeSize*TestDisp - TestAvg*TestAvg) / c_nEyeSize2);
  if (TestDisp == 0)
    return 0;
  TestAvg  /= c_nEyeSize;
  for (int i = 0; i &lt; c_nEyeSize; i++)
  {
    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);
  }
  cov /= c_nEyeSize;

  return cov / (TestDisp*SourceDisp);

}
</span> </div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;  <span class="keywordtype">double</span> TestAvg = 0;</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  <span class="keywordtype">double</span> TestDisp = 0;</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160; </div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  <span class="keywordtype">double</span> cov = 0; <span class="comment">// матожидание для результата</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160; </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  <span class="keywordflow">if</span> (eye == <a class="code" href="group___l_f_descriptors.html#gga7bba2c5e592fb982d240d5ee4235e9a6a87b49f04c2fe5b7bb932afc29812e776">LFLeftEye</a>)</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  {</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;     SourceVct  = (AWPBYTE*)m_pLeftEye-&gt;pPixels;</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;     SourceAvg  = m_fMathLeft;</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;     SourceDisp = m_fDispLeft;</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  }</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (eye == <a class="code" href="group___l_f_descriptors.html#gga7bba2c5e592fb982d240d5ee4235e9a6ad87d3473a238ac53b858d9fcfd0f5fb1">LFRightEye</a>)</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  {</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;     SourceVct  = (AWPBYTE*)m_pRightEye-&gt;pPixels;</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;     SourceAvg  = m_fMathRight;</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;     SourceDisp = m_fDispRight;</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  }</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160; </div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160; </div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>; i++)</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;  {</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    TestAvg  += TestVct[i];</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    TestDisp += TestVct[i]*TestVct[i];</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;  }</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160; </div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  TestDisp = sqrt((<a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>*TestDisp - TestAvg*TestAvg) / <a class="code" href="_l_f_eye_8cpp.html#ad3146f534a9e2c469fd3ad7430353e1d">c_nEyeSize2</a>);</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  <span class="keywordflow">if</span> (TestDisp == 0)</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;  TestAvg  /= <a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>;</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>; i++)</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;  {</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    cov += (TestVct[i] - TestAvg)*(SourceVct[i] - SourceAvg);</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  }</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  cov /= <a class="code" href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a>;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160; </div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <span class="keywordflow">return</span> cov / (TestDisp*SourceDisp);</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160; </div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;}</div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="aclass_t_l_f_roi_html"><div class="ttname"><a href="class_t_l_f_roi.html">TLFRoi</a></div><div class="ttdef"><b>Definition:</b> <a href="___l_f_8h_source.html#l00166">_LF.h:166</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_aeb6d800958733619599c199a684766fe"><div class="ttname"><a href="class_t_l_f_mosaic.html#aeb6d800958733619599c199a684766fe">TLFMosaic::m_ElWidth</a></div><div class="ttdeci">int m_ElWidth</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00041">LFEye.cpp:41</a></div></div>
<div class="ttc" id="agroup___l_f_descriptors_html_ga4ade4d13955504def49f007e5f785cf6"><div class="ttname"><a href="group___l_f_descriptors.html#ga4ade4d13955504def49f007e5f785cf6">LFPreciseMethod</a></div><div class="ttdeci">LFPreciseMethod</div><div class="ttdoc">obsolete</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00060">LFEye.h:60</a></div></div>
<div class="ttc" id="agroup___l_f_descriptors_html_gga4ade4d13955504def49f007e5f785cf6a6a93363c3c6ca2c5fdcb68a6a08ecf12"><div class="ttname"><a href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a6a93363c3c6ca2c5fdcb68a6a08ecf12">LFMean</a></div><div class="ttdeci">@ LFMean</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00060">LFEye.h:60</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_ad586648a59c911f98d869e9caeeaef1b"><div class="ttname"><a href="class_t_l_f_mosaic.html#ad586648a59c911f98d869e9caeeaef1b">TLFMosaic::TLFMosaic</a></div><div class="ttdeci">TLFMosaic()</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00189">LFEye.cpp:189</a></div></div>
<div class="ttc" id="aclass_i_l_f_eye_html_aba4c3f7ddb16243272dc05489469911c"><div class="ttname"><a href="class_i_l_f_eye.html#aba4c3f7ddb16243272dc05489469911c">ILFEye::m_IsInitialized</a></div><div class="ttdeci">bool m_IsInitialized</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00068">LFEye.h:68</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_a614da9e44621b6c13ed31f9a312d49c6"><div class="ttname"><a href="_l_f_eye_8cpp.html#a614da9e44621b6c13ed31f9a312d49c6">c_fCorrThr</a></div><div class="ttdeci">const double c_fCorrThr</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00010">LFEye.cpp:10</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_acd473e0e67a9d88658b189d86be0b00f"><div class="ttname"><a href="_l_f_eye_8cpp.html#acd473e0e67a9d88658b189d86be0b00f">c_nEyeWidth</a></div><div class="ttdeci">const int c_nEyeWidth</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00004">LFEye.cpp:4</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_ae42a45b8e85eeaded31f28d4034e4eeb"><div class="ttname"><a href="class_t_l_f_mosaic.html#ae42a45b8e85eeaded31f28d4034e4eeb">TLFMosaic::m_dy</a></div><div class="ttdeci">int m_dy</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00044">LFEye.cpp:44</a></div></div>
<div class="ttc" id="agroup___l_f_descriptors_html_ga7bba2c5e592fb982d240d5ee4235e9a6"><div class="ttname"><a href="group___l_f_descriptors.html#ga7bba2c5e592fb982d240d5ee4235e9a6">LFEyes</a></div><div class="ttdeci">LFEyes</div><div class="ttdoc">obsolete</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00056">LFEye.h:56</a></div></div>
<div class="ttc" id="aclass_t_l_f_roi_html_a4dba8f6655344cad412d3d09d656a6fe"><div class="ttname"><a href="class_t_l_f_roi.html#a4dba8f6655344cad412d3d09d656a6fe">TLFRoi::SetRoi</a></div><div class="ttdeci">void SetRoi(awpPoint lp, awpPoint rp)</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_utils_8cpp_source.html#l01278">LFUtils.cpp:1278</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_ae5a3ccd113908b52c8b4d5042c965a09"><div class="ttname"><a href="class_t_l_f_mosaic.html#ae5a3ccd113908b52c8b4d5042c965a09">TLFMosaic::~TLFMosaic</a></div><div class="ttdeci">virtual ~TLFMosaic()</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00220">LFEye.cpp:220</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_a01bfd8a0b1f59be2fa7d9357dc61b522"><div class="ttname"><a href="class_t_l_f_mosaic.html#a01bfd8a0b1f59be2fa7d9357dc61b522">TLFMosaic::AddElement</a></div><div class="ttdeci">bool AddElement(int col, int row, awpImage *pImage)</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00225">LFEye.cpp:225</a></div></div>
<div class="ttc" id="agroup___l_f_descriptors_html_gga4ade4d13955504def49f007e5f785cf6a64eb1073ca403f58988b3842c6c42eee"><div class="ttname"><a href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a64eb1073ca403f58988b3842c6c42eee">LFAverage</a></div><div class="ttdeci">@ LFAverage</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00060">LFEye.h:60</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_a2c2cc15a1f0e7b288620d3d4c780b0f8"><div class="ttname"><a href="_l_f_eye_8cpp.html#a2c2cc15a1f0e7b288620d3d4c780b0f8">_SAVE_MOSAIC_</a></div><div class="ttdeci">#define _SAVE_MOSAIC_</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00281">LFEye.cpp:281</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_ad3146f534a9e2c469fd3ad7430353e1d"><div class="ttname"><a href="_l_f_eye_8cpp.html#ad3146f534a9e2c469fd3ad7430353e1d">c_nEyeSize2</a></div><div class="ttdeci">const int c_nEyeSize2</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00007">LFEye.cpp:7</a></div></div>
<div class="ttc" id="agroup___l_f_descriptors_html_gga4ade4d13955504def49f007e5f785cf6a737034a2cfb9e73149c0f408d397cc5f"><div class="ttname"><a href="group___l_f_descriptors.html#gga4ade4d13955504def49f007e5f785cf6a737034a2cfb9e73149c0f408d397cc5f">LFExtremum</a></div><div class="ttdeci">@ LFExtremum</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00060">LFEye.h:60</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_a2c84d97b08972205633ec3ef432cfab4"><div class="ttname"><a href="class_t_l_f_mosaic.html#a2c84d97b08972205633ec3ef432cfab4">TLFMosaic::m_ElHeight</a></div><div class="ttdeci">int m_ElHeight</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00042">LFEye.cpp:42</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_a87fddd0efef4d4f0b7a2b7f89b7df45e"><div class="ttname"><a href="class_t_l_f_mosaic.html#a87fddd0efef4d4f0b7a2b7f89b7df45e">TLFMosaic::SaveMosaic</a></div><div class="ttdeci">bool SaveMosaic(const char *lpFileName)</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00244">LFEye.cpp:244</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html"><div class="ttname"><a href="class_t_l_f_mosaic.html">TLFMosaic</a></div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00036">LFEye.cpp:36</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_a08af8e3d00915acfc7ff7cb0884161be"><div class="ttname"><a href="class_t_l_f_mosaic.html#a08af8e3d00915acfc7ff7cb0884161be">TLFMosaic::m_NumCol</a></div><div class="ttdeci">int m_NumCol</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00039">LFEye.cpp:39</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_aae2664cb9766ddb80ee09be2bc84a5a3"><div class="ttname"><a href="class_t_l_f_mosaic.html#aae2664cb9766ddb80ee09be2bc84a5a3">TLFMosaic::CreateMosaic</a></div><div class="ttdeci">void CreateMosaic()</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00252">LFEye.cpp:252</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_a579c1ba6a4b0ad89bf46e215006c9bc3"><div class="ttname"><a href="_l_f_eye_8cpp.html#a579c1ba6a4b0ad89bf46e215006c9bc3">DRAW_EYE_AREA</a></div><div class="ttdeci">#define DRAW_EYE_AREA(v)</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00167">LFEye.cpp:167</a></div></div>
<div class="ttc" id="aclass_i_l_f_eye_html_a3fc11a6ebbf309a5fa3c8c4714506009"><div class="ttname"><a href="class_i_l_f_eye.html#a3fc11a6ebbf309a5fa3c8c4714506009">ILFEye::CheckEye</a></div><div class="ttdeci">virtual bool CheckEye(awpRect &amp;r, awpImage *pImage, double &amp;err, LFEyes eye)=0</div></div>
<div class="ttc" id="aclass_t_l_f_object_html"><div class="ttname"><a href="class_t_l_f_object.html">TLFObject</a></div><div class="ttdoc">Base class for all objects whithing library. Each object has the virtual destructor and name.</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_8h_source.html#l00123">LF.h:123</a></div></div>
<div class="ttc" id="a___l_f_8h_html"><div class="ttname"><a href="___l_f_8h.html">_LF.h</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_ac7889a0c5526f0d98f50648408e5c261"><div class="ttname"><a href="_l_f_eye_8cpp.html#ac7889a0c5526f0d98f50648408e5c261">c_nEyeSize</a></div><div class="ttdeci">const int c_nEyeSize</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00006">LFEye.cpp:6</a></div></div>
<div class="ttc" id="aclass_t_l_f_eye_correlation_html_a449fd6f0cbcc0ce06181292ac3e266e5"><div class="ttname"><a href="class_t_l_f_eye_correlation.html#a449fd6f0cbcc0ce06181292ac3e266e5">TLFEyeCorrelation::~TLFEyeCorrelation</a></div><div class="ttdeci">virtual ~TLFEyeCorrelation()</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00579">LFEye.cpp:579</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_aecda569513727fdc2eb85baae781ddb3"><div class="ttname"><a href="_l_f_eye_8cpp.html#aecda569513727fdc2eb85baae781ddb3">c_nEyeHalfH</a></div><div class="ttdeci">const int c_nEyeHalfH</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00009">LFEye.cpp:9</a></div></div>
<div class="ttc" id="astructtag_rect_of_interst_html_a69eb1255a6edb75158afa2d805365438"><div class="ttname"><a href="structtag_rect_of_interst.html#a69eb1255a6edb75158afa2d805365438">tagRectOfInterst::err</a></div><div class="ttdeci">double err[8]</div><div class="ttdef"><b>Definition:</b> <a href="___l_f_8h_source.html#l00103">_LF.h:103</a></div></div>
<div class="ttc" id="astructtag_rect_of_interst_html_af1346e20c62d99d4470ceeb645594d56"><div class="ttname"><a href="structtag_rect_of_interst.html#af1346e20c62d99d4470ceeb645594d56">tagRectOfInterst::p1</a></div><div class="ttdeci">awpPoint p1</div><div class="ttdef"><b>Definition:</b> <a href="___l_f_8h_source.html#l00100">_LF.h:100</a></div></div>
<div class="ttc" id="aclass_t_l_f_image_html"><div class="ttname"><a href="class_t_l_f_image.html">TLFImage</a></div><div class="ttdoc">Raster data in the awpImage format Supports Load, Save, LoadDump, SaveDump   IntegralImage for each c...</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_8h_source.html#l00227">LF.h:227</a></div></div>
<div class="ttc" id="astructtag_rect_of_interst_html"><div class="ttname"><a href="structtag_rect_of_interst.html">tagRectOfInterst</a></div><div class="ttdef"><b>Definition:</b> <a href="___l_f_8h_source.html#l00097">_LF.h:97</a></div></div>
<div class="ttc" id="aclass_t_l_f_image_html_a5a44ea86ac3f94f530665d047f95cc69"><div class="ttname"><a href="class_t_l_f_image.html#a5a44ea86ac3f94f530665d047f95cc69">TLFImage::GetImage</a></div><div class="ttdeci">awpImage * GetImage()</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_image_8cpp_source.html#l00245">LFImage.cpp:245</a></div></div>
<div class="ttc" id="aclass_t_l_f_eye_correlation_html_ae975afa3bab25c7745347b90bae77b50"><div class="ttname"><a href="class_t_l_f_eye_correlation.html#ae975afa3bab25c7745347b90bae77b50">TLFEyeCorrelation::Init</a></div><div class="ttdeci">virtual bool Init(const char *lpInitString)</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00503">LFEye.cpp:503</a></div></div>
<div class="ttc" id="agroup___l_f_descriptors_html_gga7bba2c5e592fb982d240d5ee4235e9a6ad87d3473a238ac53b858d9fcfd0f5fb1"><div class="ttname"><a href="group___l_f_descriptors.html#gga7bba2c5e592fb982d240d5ee4235e9a6ad87d3473a238ac53b858d9fcfd0f5fb1">LFRightEye</a></div><div class="ttdeci">@ LFRightEye</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00056">LFEye.h:56</a></div></div>
<div class="ttc" id="astructtag_rect_of_interst_html_a27e326c5071fb340ffd674a060b34cc1"><div class="ttname"><a href="structtag_rect_of_interst.html#a27e326c5071fb340ffd674a060b34cc1">tagRectOfInterst::p</a></div><div class="ttdeci">awpPoint p</div><div class="ttdef"><b>Definition:</b> <a href="___l_f_8h_source.html#l00099">_LF.h:99</a></div></div>
<div class="ttc" id="astructtag_rect_of_interst_html_a971f9919e08cbef413b61c1700ff0695"><div class="ttname"><a href="structtag_rect_of_interst.html#a971f9919e08cbef413b61c1700ff0695">tagRectOfInterst::EyeDistance</a></div><div class="ttdeci">double EyeDistance() const</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_utils_8cpp_source.html#l00109">LFUtils.cpp:109</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_a76e5b085c545efdcce49c6867c53b9d9"><div class="ttname"><a href="_l_f_eye_8cpp.html#a76e5b085c545efdcce49c6867c53b9d9">_ADD_TO_MOSAIC_</a></div><div class="ttdeci">#define _ADD_TO_MOSAIC_</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00263">LFEye.cpp:263</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_a426fdf4fb3cce2de932ae418146c2f37"><div class="ttname"><a href="_l_f_eye_8cpp.html#a426fdf4fb3cce2de932ae418146c2f37">c_nEyeHeight</a></div><div class="ttdeci">const int c_nEyeHeight</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00005">LFEye.cpp:5</a></div></div>
<div class="ttc" id="aclass_t_l_f_eye_correlation_html_a7ea5ef63d7490f32fb273184048f8faf"><div class="ttname"><a href="class_t_l_f_eye_correlation.html#a7ea5ef63d7490f32fb273184048f8faf">TLFEyeCorrelation::CheckEye</a></div><div class="ttdeci">virtual bool CheckEye(awpRect &amp;r, awpImage *pImage, double &amp;err, LFEyes eye)</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00585">LFEye.cpp:585</a></div></div>
<div class="ttc" id="aclass_t_l_f_eye_correlation_html_a09992dbb07140d031f32743acd6b61cc"><div class="ttname"><a href="class_t_l_f_eye_correlation.html#a09992dbb07140d031f32743acd6b61cc">TLFEyeCorrelation::TLFEyeCorrelation</a></div><div class="ttdeci">TLFEyeCorrelation()</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00497">LFEye.cpp:497</a></div></div>
<div class="ttc" id="a_l_f_eye_8cpp_html_ae2ccb26d0b914506544b2360d7e76ec4"><div class="ttname"><a href="_l_f_eye_8cpp.html#ae2ccb26d0b914506544b2360d7e76ec4">c_nEyeHalfW</a></div><div class="ttdeci">const int c_nEyeHalfW</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00008">LFEye.cpp:8</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_aa768306206ff35d9ef36ad4eb84b0050"><div class="ttname"><a href="class_t_l_f_mosaic.html#aa768306206ff35d9ef36ad4eb84b0050">TLFMosaic::m_NumRow</a></div><div class="ttdeci">int m_NumRow</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00040">LFEye.cpp:40</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_a53b9514bc650c5b4d3aeea12c8b651aa"><div class="ttname"><a href="class_t_l_f_mosaic.html#a53b9514bc650c5b4d3aeea12c8b651aa">TLFMosaic::m_dx</a></div><div class="ttdeci">int m_dx</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00043">LFEye.cpp:43</a></div></div>
<div class="ttc" id="aclass_t_l_f_roi_html_a00f69e12106a1652d2f07c5c44bd4c57"><div class="ttname"><a href="class_t_l_f_roi.html#a00f69e12106a1652d2f07c5c44bd4c57">TLFRoi::GetRoi</a></div><div class="ttdeci">TROI GetRoi()</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_utils_8cpp_source.html#l01273">LFUtils.cpp:1273</a></div></div>
<div class="ttc" id="agroup___l_f_descriptors_html_gga7bba2c5e592fb982d240d5ee4235e9a6a87b49f04c2fe5b7bb932afc29812e776"><div class="ttname"><a href="group___l_f_descriptors.html#gga7bba2c5e592fb982d240d5ee4235e9a6a87b49f04c2fe5b7bb932afc29812e776">LFLeftEye</a></div><div class="ttdeci">@ LFLeftEye</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8h_source.html#l00056">LFEye.h:56</a></div></div>
<div class="ttc" id="aclass_i_l_f_eye_html_a5d4b93166c4b25d2da0421a1b4fd54ab"><div class="ttname"><a href="class_i_l_f_eye.html#a5d4b93166c4b25d2da0421a1b4fd54ab">ILFEye::Precise</a></div><div class="ttdeci">virtual TLFRoi * Precise(TLFImage &amp;image, TLFRoi &amp;roi, LFPreciseMethod Method=LFAverage)</div><div class="ttdoc">Refines the eye position [roi] in the image [image] in case of an error returns NULL.</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00297">LFEye.cpp:297</a></div></div>
<div class="ttc" id="aclass_t_l_f_mosaic_html_a46c2ec4fcca3943807e0bf931904e23e"><div class="ttname"><a href="class_t_l_f_mosaic.html#a46c2ec4fcca3943807e0bf931904e23e">TLFMosaic::m_pImage</a></div><div class="ttdeci">awpImage * m_pImage</div><div class="ttdef"><b>Definition:</b> <a href="_l_f_eye_8cpp_source.html#l00046">LFEye.cpp:46</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
